<!DOCTYPE html>


<html lang="zh-CN">


<head>
  <meta charset="utf-8" />
   
  <meta name="keywords" content="生活,旅行,思考,代码,博客" />
   
  <meta name="description" content="一座孤岛" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     王金龙
  </title>
  <meta name="generator" content="hexo-theme-yilia-plus">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  <link rel="stylesheet" href="/dist/main.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css">
  <link rel="stylesheet" href="/css/custom.css">
  
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
  
  

  

</head>

</html>

<body>
  <div id="app">
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/ruanjian5216"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover2.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">王金龙</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>

<div id="main">
  <section class="outer">
  <article class="articles">
    
    
    
    
    <article id="post-Front-end-frame-relative" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    

    
    <div class="article-meta">
      <a href="/2020/04/16/Front-end-frame-relative/" class="article-date">
  <time datetime="2020-04-15T17:36:59.983Z" itemprop="datePublished">2020-04-16</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <p><strong>什么是单页面应用(SPA)？</strong></p>
<ul>
<li><p>单页面应用(SPA)是指用户在浏览器加载单一的HTML页面，后续请求都无需再离开此页</p>
</li>
<li><p>目标：旨在用为用户提供了更接近本地移动APP或桌面应用程序的体验。</p>
</li>
<li><p>流程：第一次请求时，将导航页传输到客户端，其余请求通过 REST API 获取 JSON 数据</p>
</li>
<li><p>实现：数据的传输通过 Web Socket API 或 RPC(远程过程调用)。</p>
</li>
<li><p>优点：用户体验流畅，服务器压力小，前后端职责分离</p>
</li>
<li><p>缺点：关键词布局难度加大，不利于 SEO</p>
</li>
</ul>
<p><strong>什么是“前端路由”? 什么时候适用“前端路由”? 有哪些优点和缺点?</strong></p>
<ul>
<li>前端路由通过 URL 和 History 来实现页面切换</li>
<li>应用：前端路由主要适用于“前后端分离”的单页面应用(SPA)项目</li>
<li>优点：用户体验好，交互流畅</li>
<li>缺点：浏览器“前进”、“后退”会重新请求，无法合理利用缓存</li>
</ul>
<p><strong>模块化开发怎么做？</strong></p>
<ul>
<li>封装对象作为命名空间 – 内部状态可以被外部改写</li>
<li>立即执行函数(IIFE) – 需要依赖多个JS文件，并且严格按顺序加载</li>
<li>使用模块加载器 – require.js, sea.js, EC6 模块</li>
</ul>
<p><strong>通行的 Javascript 模块的规范有哪些？</strong></p>
<ul>
<li>CommonJS – 主要用在服务器端 node.js</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> math = <span class="built_in">require</span>(<span class="string">'./math'</span>);</span><br><span class="line">math.add(<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>AMD(异步模块定义) – require.js</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="string">'./math'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">math</span>) </span>&#123;</span><br><span class="line">    math.add(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>CMD(通用模块定义) – sea.js </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> math = <span class="built_in">require</span>(<span class="string">'./math'</span>);</span><br><span class="line">math.add(<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>ES6 模块</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;math&#125; <span class="keyword">from</span> <span class="string">'./math'</span>;</span><br><span class="line">math.add(<span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p><strong>AMD 与 CMD 规范的区别？</strong></p>
<ul>
<li><p>规范化产出：</p>
<ul>
<li>AMD 由 RequireJS 推广产出</li>
<li>CMD 由 SeaJS 推广产出</li>
</ul>
</li>
<li><p>模块的依赖:</p>
<ul>
<li>AMD 提前执行，推崇依赖前置</li>
<li>CMD 延迟执行，推崇依赖就近</li>
</ul>
</li>
<li><p>API 功能:</p>
<ul>
<li>AMD 的 API 默认多功能（分全局 require 和局部 require）</li>
<li>CMD 的 API 推崇职责单一纯粹（没有全局 require）</li>
</ul>
<ul>
<li>模块定义规则：<ul>
<li>AMD 默认一开始就载入全部依赖模块</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">define([<span class="string">'./a'</span>, <span class="string">'./b'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    a.doSomething();</span><br><span class="line">    b.doSomething();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>CMD 依赖模块在用到时才就近载入</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>);</span><br><span class="line">    a.doSomething();</span><br><span class="line">    <span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">'./b'</span>);</span><br><span class="line">    b.doSomething();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>requireJS的核心原理是什么？</strong></p>
<ul>
<li>每个模块所依赖模块都会比本模块预先加载</li>
</ul>
<p><strong>对 Node.js 的优点、缺点提出了自己的看法？ Node.js的特点和适用场景？</strong></p>
<ul>
<li>Node.js的特点：单线程，非阻塞I/O，事件驱动</li>
<li>Node.js的优点：擅长处理高并发；适合I/O密集型应用</li>
</ul>
<ul>
<li><p>Node.js的缺点：不适合CPU密集运算；不能充分利用多核CPU；可靠性低，某个环节出错会导致整个系统崩溃</p>
<ul>
<li>Node.js的适用场景：<ul>
<li>RESTful API</li>
<li>实时应用：在线聊天、图文直播</li>
<li>工具类应用：前端部署(npm, gulp)</li>
<li>表单收集：问卷系统</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>如何判断当前脚本运行在浏览器还是node环境中？</strong></p>
<ul>
<li>判断 Global 对象是否为 window，如果不为 window，当前脚本没有运行在浏览器中</li>
</ul>
<p><strong>什么是 npm ？</strong></p>
<ul>
<li>npm 是 Node.js 的模块管理和发布工具</li>
</ul>
<p><strong>什么是 WebKit ？</strong></p>
<ul>
<li>WebKit 是一个开源的浏览器内核，由渲染引擎(WebCore)和JS解释引擎(JSCore)组成</li>
<li>通常所说的 WebKit 指的是 WebKit(WebCore)，主要工作是进行 HTML/CSS 渲染</li>
<li>WebKit 一直是 Safari 和 Chrome(之前) 使用的浏览器内核，后来 Chrome 改用Blink 内核</li>
</ul>
<p><strong>如何测试前端代码? 知道 Unit Test，BDD, TDD 么? 怎么测试你的前端工程(mocha, jasmin..)?</strong></p>
<ul>
<li>通过为前端代码编写单元测试(Unit Test)来测试前端代码</li>
<li>Unit Test：一段用于测试一个模块或接口是否能达到预期结果的代码</li>
<li>BDD：行为驱动开发 – 业务需求描述产出产品代码的开发方法</li>
<li>TDD：测试驱动开发 – 单元测试用例代码产出产品代码的开发方法</li>
<li>单元测试框架：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mocha 示例</span></span><br><span class="line">describe(<span class="string">'Test add'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  it(<span class="string">'1 + 2 = 3'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      expect(add(<span class="number">1</span>, <span class="number">2</span>)).to.be.equal(<span class="number">3</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// jasmin 示例</span></span><br><span class="line">describe(<span class="string">'Test add'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    it(<span class="string">'1 + 2 = 3'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        expect(add(<span class="number">1</span>, <span class="number">2</span>)).toEqual(<span class="number">3</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>介绍你知道的前端模板引擎？</strong></p>
<ul>
<li>artTemplate, underscore, handlebars</li>
</ul>
<p><strong>什么是 Modernizr？ Modernizr 工作原理？</strong></p>
<ul>
<li>Modernizr 是一个开源的 JavaScript 库，用于检测用户浏览器对 HTML5 与 CSS3 的支持情况</li>
</ul>
<p><strong>移动端最小触控区域是多大？</strong></p>
<ul>
<li>44 * 44 px</li>
</ul>
<p><strong>移动端的点击事件的延迟时间是多长，为什么会有延迟？ 如何解决这个延时？</strong></p>
<ul>
<li>移动端 click 有 300ms 延迟，浏览器为了区分“双击”（放大页面）还是“单击”而设计</li>
<li>解决方案：<ul>
<li>禁用缩放(对safari无效)</li>
<li>使用指针事件(IE私有特性，且仅IE10+)</li>
<li>使用 Zepto 的 tap 事件(有点透BUG)</li>
<li>使用 FastClick 插件(体积大[压缩后8k])</li>
</ul>
</li>
</ul>
<p><strong>什么是函数式编程？</strong></p>
<ul>
<li><p>函数式编程是一种”编程范式”，主要思想是把运算过程尽量写成一系列嵌套的函数调用</p>
</li>
<li><p>例如：var result = subtract(multiply(add(1,2), 3), 4);</p>
</li>
<li><p>函数式编程的特点：</p>
<ul>
<li>函数核心化：函数可以作为变量的赋值、另一函数的参数、另一函数的返回值</li>
<li>只用“表达式”，不用“语句”：要求每一步都是单纯的运算，都必须有返回值</li>
<li>没有”副作用”：所有功能只为返回一个新的值，不修改外部变量</li>
<li>引用透明：运行不依赖于外部变量，只依赖于输入的参数</li>
</ul>
</li>
<li><p>函数式编程的优点：</p>
<ul>
<li>代码简洁，接近自然语言，易于理解</li>
<li>便于维护，利于测试、除错、组合</li>
<li>易于“并发编程“，不用担心一个线程的数据，被另一个线程修改</li>
<li>可“热升级”代码，在运行状态下直接升级代码，不需要重启，也不需要停机</li>
</ul>
</li>
</ul>
<p><strong>什么是函数柯里化Currying)？</strong></p>
<ul>
<li><p>柯里化：</p>
<ul>
<li>通常也称部分求值，含义是给函数分步传递参数，每次递参部分应用参数，并返回一个更具体的函数，继续接受剩余参数</li>
<li>期间会连续返回具体函数，直至返回最后结果。因此，函数柯里化是逐步传参，逐步缩小函数的适用范围，逐步求解的过程</li>
<li>柯里化的作用：延迟计算；参数复用；动态创建函数</li>
</ul>
</li>
<li><p>柯里化的缺点：</p>
<ul>
<li>函数柯里化会产生开销（函数嵌套，比普通函数占更多内存），但性能瓶颈首先来自其它原因（DOM 操作等）</li>
</ul>
</li>
</ul>
<p><strong>什么是依赖注入？</strong></p>
<ul>
<li>当一个类的实例依赖另一个类的实例时，自己不创建该实例，由IOC容器创建并注入给自己，因此称为依赖注入。</li>
<li>依赖注入解决的就是如何有效组织代码依赖模块的问题</li>
</ul>
<p><strong>设计模式：什么是 singleton, factory, strategy, decorator？</strong></p>
<ul>
<li>Singleton(单例)   一个类只有唯一实例，这个实例在整个程序中有一个全局的访问点</li>
<li>Factory (工厂)    解决实列化对象产生重复的问题</li>
<li>Strategy(策略)    将每一个算法封装起来，使它们还可以相互替换，让算法独立于使用</li>
<li>Observer(观察者)  多个观察者同时监听一个主体，当主体对象发生改变时，所有观察者都将得到通知</li>
<li>Prototype(原型)   一个完全初始化的实例，用于拷贝或者克隆</li>
<li>Adapter(适配器)   将不同类的接口进行匹配调整，尽管内部接口不兼容，不同的类还是可以协同工作</li>
<li>Proxy(代理模式)   一个充当过滤转发的对象用来代表一个真实的对象</li>
<li>Iterator(迭代器)  在不需要直到集合内部工作原理的情况下，顺序访问一个集合里面的元素</li>
<li>Chain of Responsibility(职责连)  处理请求组成的对象一条链，请求链中传递，直到有对象可以处理</li>
</ul>
<p><strong>什么是前端工程化？</strong></p>
<ul>
<li>前端工程化就是把一整套前端工作流程使用工具自动化完成</li>
</ul>
<ul>
<li>前端开发基本流程：<ul>
<li>项目初始化：yeoman, FIS</li>
<li>引入依赖包：bower, npm</li>
<li>模块化管理：npm, browserify, Webpack</li>
<li>代码编译：babel, sass, less</li>
<li>代码优化(压缩/合并)：Gulp, Grunt</li>
<li>代码检查：JSHint, ESLint</li>
<li>代码测试：Mocha</li>
</ul>
</li>
<li>目前最知名的构建工具：Gulp, Grunt, npm + Webpack</li>
</ul>
<p><strong>介绍 Yeoman 是什么？</strong></p>
<ul>
<li>Yeoman –前端开发脚手架工具，自动将最佳实践和工具整合起来构建项目骨架</li>
<li>Yeoman 其实是三类工具的合体，三类工具各自独立：<ul>
<li>yo — 脚手架，自动生成工具（相当于一个粘合剂，把 Yeoman 工具粘合在一起）</li>
<li>Grunt、gulp — 自动化构建工具 （最初只有grunt，之后加入了gulp）</li>
<li>Bower、npm — 包管理工具 （原来是bower，之后加入了npm）</li>
</ul>
</li>
</ul>
<p><strong>介绍 WebPack 是什么？ 有什么优势？</strong></p>
<ul>
<li>WebPack 是一款[模块加载器]兼[打包工具]，用于把各种静态资源（js/css/image等）作为模块来使用</li>
<li>WebPack 的优势：<ul>
<li>WebPack 同时支持 commonJS 和 AMD/CMD，方便代码迁移</li>
<li>不仅仅能被模块化 JS ，还包括 CSS、Image 等</li>
<li>能替代部分 grunt/gulp 的工作，如打包、压缩混淆、图片base64</li>
<li>扩展性强，插件机制完善，特别是支持 React 热插拔的功能</li>
</ul>
</li>
</ul>
<p><strong>介绍类库和框架的区别？</strong></p>
<ul>
<li>类库是一些函数的集合，帮助开发者写WEB应用，起主导作用的是开发者的代码</li>
<li>框架是已实现的特殊WEB应用，开发者只需对它填充具体的业务逻辑，起主导作用是框架</li>
</ul>
<p><strong>什么是 MVC/MVP/MVVM/Flux？</strong></p>
<ul>
<li>MVC(Model-View-Controller) <ul>
<li>V-&gt;C, C-&gt;M, M-&gt;V</li>
<li>通信都是单向的；C只起路由作用，业务逻辑都部署在V</li>
<li>Backbone</li>
</ul>
</li>
</ul>
<ul>
<li><p>MVP(Model-View-Presenter)</p>
<ul>
<li>V&lt;-&gt;P, P&lt;-&gt;M</li>
<li>通信都是双向的；V和M不发生联系(通过P传)；V非常薄，逻辑都部署在P</li>
<li>Riot.js</li>
</ul>
</li>
<li><p>MVVM(Model-View-ViewModel)</p>
<ul>
<li>V-&gt;VM, VM&lt;-&gt;M</li>
<li>采用双向数据绑定：View 和 ViewModel 的变动都会相互映射到对象上面</li>
<li>Angular</li>
</ul>
</li>
<li><p>Flux(Dispatcher-Store-View)</p>
<ul>
<li>Action-&gt;Dispatcher-&gt;Store-&gt;View, View-&gt;Action</li>
<li>Facebook 为了解决在 MVC 应用中碰到的工程性问题提出一个架构思想</li>
<li>基于一个简单的原则：数据在应用中单向流动（单向数据流）</li>
<li>React(Flux 中 View，只关注表现层)</li>
</ul>
</li>
</ul>
<p><strong>Backbone 是什么？</strong></p>
<ul>
<li>Backbone 是一个基于 jquery 和 underscore 的前端(MVC)框架</li>
</ul>
<p><strong>AngularJS 是什么？</strong></p>
<ul>
<li>AngularJS 是一个完善的前端 MVVM 框架，包含模板、数据双向绑定、路由、模块化、服务、依赖注入等</li>
<li>AngularJS 由 Google 维护，用来协助大型单一页面应用开发。</li>
</ul>
<p><strong>React 是什么？</strong></p>
<ul>
<li>React 不是 MV* 框架，用于构建用户界面的 JavaScript 库，侧重于 View 层</li>
<li>React 主要的原理：<ul>
<li>虚拟 DOM + diff 算法 -&gt; 不直接操作 DOM 对象</li>
<li>Components 组件 -&gt; Virtual DOM 的节点</li>
<li>State 触发视图的渲染 -&gt; 单向数据绑定</li>
<li>React 解决方案：React + Redux + react-router + Fetch + webpack</li>
</ul>
</li>
</ul>
<p><strong>react-router 路由系统的实现原理？</strong></p>
<ul>
<li>实现原理：location 与 components 之间的同步</li>
</ul>
<ul>
<li>路由的职责是保证 UI 和 URL 的同步</li>
<li>在 react-router 中，URL 对应 Location 对象，UI 由 react components 决定</li>
<li>因此，路由在 react-router 中就转变成 location 与 components 之间的同步</li>
</ul>
<p><strong>Meteor 是什么</strong></p>
<ul>
<li>Meteor 是一个全栈开发框架，基础构架是 Node.JS + MongoDB，并把延伸到了浏览器端。</li>
<li>Meteor 统一了服务器端和客户端的数据访问，使开发者可以轻松完成全栈式开发工作。</li>
</ul>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  
  
  

</article>
    
    <article id="post-ES6" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    

    
    <div class="article-meta">
      <a href="/2020/04/16/ES6/" class="article-date">
  <time datetime="2020-04-15T17:36:59.969Z" itemprop="datePublished">2020-04-16</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h2 id="1、ES5、ES6和ES2015有什么区别"><a href="#1、ES5、ES6和ES2015有什么区别" class="headerlink" title="1、ES5、ES6和ES2015有什么区别?"></a>1、ES5、ES6和ES2015有什么区别?</h2><blockquote>
<p><code>ES2015</code>特指在<code>2015</code>年发布的新一代<code>JS</code>语言标准，<code>ES6</code>泛指下一代JS语言标准，包含<code>ES2015</code>、<code>ES2016</code>、<code>ES2017</code>、<code>ES2018</code>等。现阶段在绝大部分场景下，<code>ES2015</code>默认等同<code>ES6</code>。<code>ES5</code>泛指上一代语言标准。<code>ES2015</code>可以理解为<code>ES5</code>和<code>ES6</code>的时间分界线</p>
</blockquote>
<h2 id="2、babel是什么，有什么作用"><a href="#2、babel是什么，有什么作用" class="headerlink" title="2、babel是什么，有什么作用?"></a>2、babel是什么，有什么作用?</h2><blockquote>
<p><code>babel</code>是一个 <code>ES6</code> 转码器，可以将 <code>ES6</code> 代码转为 <code>ES5</code> 代码，以便兼容那些还没支持<code>ES6</code>的平台</p>
</blockquote>
<h2 id="3、let有什么用，有了var为什么还要用let？"><a href="#3、let有什么用，有了var为什么还要用let？" class="headerlink" title="3、let有什么用，有了var为什么还要用let？"></a>3、let有什么用，有了var为什么还要用let？</h2><blockquote>
<p>在<code>ES6</code>之前，声明变量只能用<code>var</code>，<code>var</code>方式声明变量其实是很不合理的，准确的说，是因为<code>ES5</code>里面没有块级作用域是很不合理的。没有块级作用域回来带很多难以理解的问题，比如<code>for</code>循环<code>var</code>变量泄露，变量覆盖等问题。<code>let</code>声明的变量拥有自己的块级作用域，且修复了<code>var</code>声明变量带来的变量提升问题。</p>
</blockquote>
<h2 id="4、举一些ES6对String字符串类型做的常用升级优化"><a href="#4、举一些ES6对String字符串类型做的常用升级优化" class="headerlink" title="4、举一些ES6对String字符串类型做的常用升级优化?"></a>4、举一些ES6对String字符串类型做的常用升级优化?</h2><p><strong>优化部分</strong></p>
<blockquote>
<p><code>ES6</code>新增了字符串模板，在拼接大段字符串时，用反斜杠<code>(</code>)`取代以往的字符串相加的形式，能保留所有空格和换行，使得字符串拼接看起来更加直观，更加优雅</p>
</blockquote>
<p><strong>升级部分</strong></p>
<blockquote>
<p><code>ES6</code>在<code>String</code>原型上新增了<code>includes()</code>方法，用于取代传统的只能用<code>indexOf</code>查找包含字符的方法(<code>indexOf</code>返回<code>-1</code>表示没查到不如<code>includes</code>方法返回<code>false</code>更明确，语义更清晰), 此外还新增了<code>startsWith()</code>, <code>endsWith(),</code> <code>padStart()</code>,<code>padEnd()</code>,<code>repeat()</code>等方法，可方便的用于查找，补全字符串</p>
</blockquote>
<h2 id="5、举一些ES6对Array数组类型做的常用升级优化"><a href="#5、举一些ES6对Array数组类型做的常用升级优化" class="headerlink" title="5、举一些ES6对Array数组类型做的常用升级优化"></a>5、举一些ES6对Array数组类型做的常用升级优化</h2><p><strong>优化部分</strong></p>
<ul>
<li>数组解构赋值。<code>ES6</code>可以直接以<code>let [a,b,c] = [1,2,3]</code>形式进行变量赋值，在声明较多变量时，不用再写很多<code>let(var),</code>且映射关系清晰，且支持赋默认值</li>
<li>扩展运算符。<code>ES6</code>新增的扩展运算符(<code>...</code>)(重要),可以轻松的实现数组和松散序列的相互转化，可以取代<code>arguments</code>对象和<code>apply</code>方法，轻松获取未知参数个数情况下的参数集合。（尤其是在<code>ES5</code>中，<code>arguments</code>并不是一个真正的数组，而是一个类数组的对象，但是扩展运算符的逆运算却可以返回一个真正的数组）。扩展运算符还可以轻松方便的实现数组的复制和解构赋值（<code>let a = [2,3,4]</code>; <code>let b = [...a]</code>）</li>
</ul>
<p><strong>升级部分</strong></p>
<blockquote>
<p><code>ES6</code>在<code>Array</code>原型上新增了<code>find()</code>方法，用于取代传统的只能用<code>indexOf</code>查找包含数组项目的方法,且修复了<code>indexOf</code>查找不到<code>NaN的bug([NaN].indexOf(NaN) === -1)</code>.此外还新增了<code>copyWithin()</code>,<code>includes()</code>, <code>fill()</code>,<code>flat()</code>等方法，可方便的用于字符串的查找，补全,转换等</p>
</blockquote>
<h2 id="6、举一些ES6对Number数字类型做的常用升级优化"><a href="#6、举一些ES6对Number数字类型做的常用升级优化" class="headerlink" title="6、举一些ES6对Number数字类型做的常用升级优化"></a>6、举一些ES6对Number数字类型做的常用升级优化</h2><p><strong>优化部分</strong></p>
<blockquote>
<p>ES6在<code>Number</code>原型上新增了<code>isFinite()</code>, <code>isNaN()</code>方法，用来取代传统的全局<code>isFinite(),</code> <code>isNaN()</code>方法检测数值是否有限、是否是<code>NaN</code>。<code>ES5</code>的<code>isFinite()</code>, <code>isNaN()</code>方法都会先将非数值类型的参数转化为<code>Number</code>类型再做判断，这其实是不合理的，最造成i<code>sNaN(&#39;NaN&#39;) === true</code>的奇怪行为<code>--&#39;NaN&#39;</code>是一个字符串，但是<code>isNaN</code>却说这就是<code>NaN</code>。而<code>Number.isFinite()</code>和<code>Number.isNaN()</code>则不会有此类问题(<code>Number.isNaN(&#39;NaN&#39;) === false</code>)。（<code>isFinite()</code>同上）</p>
</blockquote>
<p><strong>升级部分</strong></p>
<blockquote>
<p><code>ES6</code>在<code>Math</code>对象上新增了<code>Math.cbrt()</code>，<code>trunc()</code>，<code>hypot()</code>等等较多的科学计数法运算方法，可以更加全面的进行立方根、求和立方根等等科学计算</p>
</blockquote>
<h2 id="7、举一些ES6对Object类型做的常用升级优化-重要"><a href="#7、举一些ES6对Object类型做的常用升级优化-重要" class="headerlink" title="7、举一些ES6对Object类型做的常用升级优化?(重要)"></a>7、举一些ES6对Object类型做的常用升级优化?(重要)</h2><p><strong>优化部分</strong></p>
<blockquote>
<p>对象属性变量式声明。<code>ES6</code>可以直接以变量形式声明对象属性或者方法，。比传统的键值对形式声明更加简洁，更加方便，语义更加清晰</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [apple, orange] = [<span class="string">'red appe'</span>, <span class="string">'yellow orange'</span>];</span><br><span class="line"><span class="keyword">let</span> myFruits = &#123;apple, orange&#125;;    <span class="comment">// let myFruits = &#123;apple: 'red appe', orange: 'yellow orange'&#125;;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>尤其在对象解构赋值(见优化部分b.)或者模块输出变量时，这种写法的好处体现的最为明显</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;keys, values, entries&#125; = <span class="built_in">Object</span>;</span><br><span class="line"><span class="keyword">let</span> MyOwnMethods = &#123;keys, values, entries&#125;; <span class="comment">// let MyOwnMethods = &#123;keys: keys, values: values, entries: entries&#125;</span></span><br></pre></td></tr></table></figure>

<p>可以看到属性变量式声明属性看起来更加简洁明了。方法也可以采用简洁写法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> es5Fun = &#123;</span><br><span class="line">    method: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">let</span> es6Fun = &#123;</span><br><span class="line">    method()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对象的解构赋值。 <code>ES6</code>对象也可以像数组解构赋值那样，进行变量的解构赋值</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;apple, orange&#125; = &#123;<span class="attr">apple</span>: <span class="string">'red appe'</span>, <span class="attr">orange</span>: <span class="string">'yellow orange'</span>&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对象的扩展运算符(<code>...</code>)。 ES6对象的扩展运算符和数组扩展运算符用法本质上差别不大，毕竟数组也就是特殊的对象。对象的扩展运算符一个最常用也最好用的用处就在于可以轻松的取出一个目标对象内部全部或者部分的可遍历属性，从而进行对象的合并和分解</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;apple, orange, ...otherFruits&#125; = &#123;<span class="attr">apple</span>: <span class="string">'red apple'</span>, <span class="attr">orange</span>: <span class="string">'yellow orange'</span>, <span class="attr">grape</span>: <span class="string">'purple grape'</span>, <span class="attr">peach</span>: <span class="string">'sweet peach'</span>&#125;; </span><br><span class="line"><span class="comment">// otherFruits  &#123;grape: 'purple grape', peach: 'sweet peach'&#125;</span></span><br><span class="line"><span class="comment">// 注意: 对象的扩展运算符用在解构赋值时，扩展运算符只能用在最有一个参数(otherFruits后面不能再跟其他参数)</span></span><br><span class="line"><span class="keyword">let</span> moreFruits = &#123;<span class="attr">watermelon</span>: <span class="string">'nice watermelon'</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> allFruits = &#123;apple, orange, ...otherFruits, ...moreFruits&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>super</code> 关键字。<code>ES6</code>在<code>Class</code>类里新增了类似<code>this</code>的关键字<code>super</code>。同<code>this</code>总是指向当前函数所在的对象不同，<code>super</code>关键字总是指向当前函数所在对象的原型对象</p>
</blockquote>
<p><strong>升级部分</strong></p>
<blockquote>
<p><code>ES6</code>在<code>Object</code>原型上新增了<code>is()</code>方法，做两个目标对象的相等比较，用来完善<code>&#39;===&#39;</code>方法。<code>&#39;===&#39;</code>方法中<code>NaN === NaN //false</code>其实是不合理的，<code>Object.is</code>修复了这个小<code>bug</code>。<code>(Object.is(NaN, NaN) // true)</code></p>
</blockquote>
<blockquote>
<p><code>ES6</code>在<code>Object</code>原型上新增了<code>assign()</code>方法，用于对象新增属性或者多个对象合并</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> source1 = &#123; <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> source2 = &#123; <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(target, source1, source2);</span><br><span class="line">target <span class="comment">// &#123;a:1, b:2, c:3&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong>: <code>assign</code>合并的对象<code>target</code>只能合并<code>source1</code>、s<code>ource2</code>中的自身属性，并不会合并<code>source1</code>、<code>source2</code>中的继承属性，也不会合并不可枚举的属性，且无法正确复制get和set属性（会直接执行<code>get/set</code>函数，取<code>return</code>的值）</p>
</blockquote>
<ul>
<li><code>ES6</code>在<code>Object</code>原型上新增了<code>getOwnPropertyDescriptors()</code>方法，此方法增强了<code>ES5</code>中<code>getOwnPropertyDescriptor()</code>方法，可以获取指定对象所有自身属性的描述对象。结合<code>defineProperties()</code>方法，可以完美复制对象，包括复制<code>get</code>和<code>set</code>属性</li>
<li><code>ES6</code>在<code>Object</code>原型上新增了<code>getPrototypeOf()</code>和<code>setPrototypeOf()</code>方法，用来获取或设置当前对象的<code>prototype</code>对象。这个方法存在的意义在于，<code>ES5</code>中获取设置<code>prototype</code>对像是通过<code>__proto__</code>属性来实现的，然而<code>__proto__</code>属性并不是ES规范中的明文规定的属性，只是浏览器各大产商“私自”加上去的属性，只不过因为适用范围广而被默认使用了，再非浏览器环境中并不一定就可以使用，所以为了稳妥起见，获取或设置当前对象的<code>prototype</code>对象时，都应该采用ES6新增的标准用法</li>
<li><code>ES6</code>在<code>Object</code>原型上还新增了<code>Object.keys()</code>，<code>Object.values()</code>，<code>Object.entries()</code>方法，用来获取对象的所有键、所有值和所有键值对数组</li>
</ul>
<h2 id="8、举一些ES6对Function函数类型做的常用升级优化"><a href="#8、举一些ES6对Function函数类型做的常用升级优化" class="headerlink" title="8、举一些ES6对Function函数类型做的常用升级优化?"></a>8、举一些ES6对Function函数类型做的常用升级优化?</h2><p><strong>优化部分</strong></p>
<blockquote>
<p>箭头函数(核心)。箭头函数是ES6核心的升级项之一，箭头函数里没有自己的this,这改变了以往JS函数中最让人难以理解的this运行机制。主要优化点</p>
</blockquote>
<ul>
<li>箭头函数内的this指向的是函数定义时所在的对象，而不是函数执行时所在的对象。ES5函数里的this总是指向函数执行时所在的对象，这使得在很多情况下<code>this</code>的指向变得很难理解，尤其是非严格模式情况下，<code>this</code>有时候会指向全局对象，这甚至也可以归结为语言层面的bug之一。ES6的箭头函数优化了这一点，它的内部没有自己的<code>this</code>,这也就导致了<code>this</code>总是指向上一层的<code>this</code>，如果上一层还是箭头函数，则继续向上指，直到指向到有自己<code>this</code>的函数为止，并作为自己的<code>this</code></li>
<li>箭头函数不能用作构造函数，因为它没有自己的<code>this</code>，无法实例化</li>
<li>也是因为箭头函数没有自己的this,所以箭头函数 内也不存在<code>arguments</code>对象。（可以用扩展运算符代替）</li>
<li>函数默认赋值。<code>ES6</code>之前，函数的形参是无法给默认值得，只能在函数内部通过变通方法实现。<code>ES6</code>以更简洁更明确的方式进行函数默认赋值</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">es6Fuc</span> (<span class="params">x, y = <span class="string">'default'</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line">es6Fuc(<span class="number">4</span>) <span class="comment">// 4, default</span></span><br></pre></td></tr></table></figure>

<p><strong>升级部分</strong></p>
<blockquote>
<p>ES6新增了双冒号运算符，用来取代以往的<code>bind</code>，<code>call</code>,和<code>apply</code>。(浏览器暂不支持，<code>Babel</code>已经支持转码)</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">foo::bar;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">bar.bind(foo);</span><br><span class="line"></span><br><span class="line">foo::bar(...arguments);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">bar.apply(foo, <span class="built_in">arguments</span>);</span><br></pre></td></tr></table></figure>

<h2 id="9、Symbol是什么，有什么作用？"><a href="#9、Symbol是什么，有什么作用？" class="headerlink" title="9、Symbol是什么，有什么作用？"></a>9、Symbol是什么，有什么作用？</h2><blockquote>
<p><code>Symbol</code>是<code>ES6</code>引入的第七种原始数据类型（说法不准确，应该是第七种数据类型，Object不是原始数据类型之一，已更正），所有Symbol()生成的值都是独一无二的，可以从根本上解决对象属性太多导致属性名冲突覆盖的问题。对象中<code>Symbol()</code>属性不能被<code>for...in</code>遍历，但是也不是私有属性</p>
</blockquote>
<h2 id="10、Set是什么，有什么作用？"><a href="#10、Set是什么，有什么作用？" class="headerlink" title="10、Set是什么，有什么作用？"></a>10、Set是什么，有什么作用？</h2><blockquote>
<p><code>Set</code>是<code>ES6</code>引入的一种类似<code>Array</code>的新的数据结构，<code>Set</code>实例的成员类似于数组<code>item</code>成员，区别是<code>Set</code>实例的成员都是唯一，不重复的。这个特性可以轻松地实现数组去重</p>
</blockquote>
<h2 id="11、Map是什么，有什么作用？"><a href="#11、Map是什么，有什么作用？" class="headerlink" title="11、Map是什么，有什么作用？"></a>11、Map是什么，有什么作用？</h2><blockquote>
<p><code>Map</code>是<code>ES6</code>引入的一种类似<code>Object</code>的新的数据结构，<code>Map</code>可以理解为是<code>Object</code>的超集，打破了以传统键值对形式定义对象，对象的<code>key</code>不再局限于字符串，也可以是<code>Object</code>。可以更加全面的描述对象的属性</p>
</blockquote>
<h2 id="12、Proxy是什么，有什么作用？"><a href="#12、Proxy是什么，有什么作用？" class="headerlink" title="12、Proxy是什么，有什么作用？"></a>12、Proxy是什么，有什么作用？</h2><blockquote>
<p><code>Proxy</code>是<code>ES6</code>新增的一个构造函数，可以理解为JS语言的一个代理，用来改变JS默认的一些语言行为，包括拦截默认的<code>get/set</code>等底层方法，使得JS的使用自由度更高，可以最大限度的满足开发者的需求。比如通过拦截对象的<code>get/set</code>方法，可以轻松地定制自己想要的<code>key</code>或者<code>value</code>。下面的例子可以看到，随便定义一个<code>myOwnObj</code>的<code>key</code>,都可以变成自己想要的函数`</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createMyOwnObj</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="comment">//想把所有的key都变成函数，或者Promise,或者anything</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">		<span class="keyword">get</span>(target, propKey, receiver) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">				setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">					<span class="keyword">let</span> randomBoolean = <span class="built_in">Math</span>.random() &gt; <span class="number">0.5</span>;</span><br><span class="line">					<span class="keyword">let</span> Message;</span><br><span class="line">					<span class="keyword">if</span> (randomBoolean) &#123;</span><br><span class="line">						Message = <span class="string">`你的<span class="subst">$&#123;propKey&#125;</span>运气不错，成功了`</span>;</span><br><span class="line">						resolve(Message);</span><br><span class="line">					&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						Message = <span class="string">`你的<span class="subst">$&#123;propKey&#125;</span>运气不行，失败了`</span>;</span><br><span class="line">						reject(Message);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;, <span class="number">1000</span>);</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myOwnObj = createMyOwnObj();</span><br><span class="line"></span><br><span class="line">myOwnObj.hahaha.then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(result) <span class="comment">//你的hahaha运气不错，成功了</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(error) <span class="comment">//你的hahaha运气不行，失败了</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">myOwnObj.wuwuwu.then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(result) <span class="comment">//你的wuwuwu运气不错，成功了</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(error) <span class="comment">//你的wuwuwu运气不行，失败了</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="13、Reflect是什么，有什么作用？"><a href="#13、Reflect是什么，有什么作用？" class="headerlink" title="13、Reflect是什么，有什么作用？"></a>13、Reflect是什么，有什么作用？</h2><blockquote>
<p><code>Reflect</code>是<code>ES6</code>引入的一个新的对象，他的主要作用有两点，一是将原生的一些零散分布在<code>Object</code>、<code>Function</code>或者全局函数里的方法(如<code>apply</code>、<code>delete</code>、<code>get</code>、<code>set</code>等等)，统一整合到<code>Reflect</code>上，这样可以更加方便更加统一的管理一些原生<code>API</code>。其次就是因为<code>Proxy</code>可以改写默认的原生API，如果一旦原生<code>API</code>别改写可能就找不到了，所以<code>Reflect</code>也可以起到备份原生API的作用，使得即使原生<code>API</code>被改写了之后，也可以在被改写之后的<code>API</code>用上默认的<code>API</code></p>
</blockquote>
<h2 id="14、Promise是什么，有什么作用？"><a href="#14、Promise是什么，有什么作用？" class="headerlink" title="14、Promise是什么，有什么作用？"></a>14、Promise是什么，有什么作用？</h2><blockquote>
<p><code>Promise</code>是<code>ES6</code>引入的一个新的对象，他的主要作用是用来解决JS异步机制里，回调机制产生的“回调地狱”。它并不是什么突破性的<code>API</code>，只是封装了异步回调形式，使得异步回调可以写的更加优雅，可读性更高，而且可以链式调用</p>
</blockquote>
<h2 id="15、Iterator是什么，有什么作用？-重要"><a href="#15、Iterator是什么，有什么作用？-重要" class="headerlink" title="15、Iterator是什么，有什么作用？(重要)"></a>15、Iterator是什么，有什么作用？(重要)</h2><ul>
<li><code>Iterator</code>是<code>ES6</code>中一个很重要概念，它并不是对象，也不是任何一种数据类型。因为<code>ES6</code>新增了<code>Set</code>、<code>Map</code>类型，他们和<code>Array</code>、<code>Object</code>类型很像，<code>Array</code>、<code>Object</code>都是可以遍历的，但是<code>Set</code>、<code>Map</code>都不能用for循环遍历，解决这个问题有两种方案，一种是为<code>Set</code>、<code>Map</code>单独新增一个用来遍历的<code>API</code>，另一种是为<code>Set</code>、<code>Map</code>、<code>Array</code>、<code>Object</code>新增一个统一的遍历<code>API</code>，显然，第二种更好，<code>ES6</code>也就顺其自然的需要一种设计标准，来统一所有可遍历类型的遍历方式。<code>Iterator</code>正是这样一种标准。或者说是一种规范理念</li>
<li>就好像<code>JavaScript</code>是<code>ECMAScript</code>标准的一种具体实现一样，<code>Iterator</code>标准的具体实现是<code>Iterator</code>遍历器。<code>Iterator</code>标准规定，所有部署了<code>key</code>值为<code>[Symbol.iterator]</code>，且<code>[Symbol.iterator]</code>的<code>value</code>是标准的<code>Iterator</code>接口函数(标准的<code>Iterator</code>接口函数: 该函数必须返回一个对象，且对象中包含<code>next</code>方法，且执行<code>next()</code>能返回包含<code>value/done</code>属性的<code>Iterator</code>对象)的对象，都称之为可遍历对象，<code>next()</code>后返回的<code>Iterator</code>对象也就是<code>Iterator</code>遍历器</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//obj就是可遍历的，因为它遵循了Iterator标准，且包含[Symbol.iterator]方法，方法函数也符合标准的Iterator接口规范。</span></span><br><span class="line"><span class="comment">//obj.[Symbol.iterator]() 就是Iterator遍历器</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  data: [ <span class="string">'hello'</span>, <span class="string">'world'</span> ],</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="keyword">const</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      next() &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; self.data.length) &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123;</span><br><span class="line">            value: self.data[index++],</span><br><span class="line">            done: <span class="literal">false</span></span><br><span class="line">          &#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123; <span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>ES6</code>给<code>Set</code>、<code>Map</code>、<code>Array</code>、<code>String</code>都加上了<code>[Symbol.iterator]</code>方法，且<code>[Symbol.iterator]</code>方法函数也符合标准的<code>Iterator</code>接口规范，所以<code>Set</code>、<code>Map</code>、<code>Array</code>、<code>String</code>默认都是可以遍历的</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Array</span></span><br><span class="line"><span class="keyword">let</span> array = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>];</span><br><span class="line">array[<span class="built_in">Symbol</span>.iterator]() <span class="comment">//Iterator遍历器</span></span><br><span class="line">array[<span class="built_in">Symbol</span>.iterator]().next() <span class="comment">//&#123;value: "red", done: false&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//String</span></span><br><span class="line"><span class="keyword">let</span> string = <span class="string">'1122334455'</span>;</span><br><span class="line">string[<span class="built_in">Symbol</span>.iterator]() <span class="comment">//Iterator遍历器</span></span><br><span class="line">string[<span class="built_in">Symbol</span>.iterator]().next() <span class="comment">//&#123;value: "1", done: false&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//set</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set(['red', 'green', 'blue']);</span><br><span class="line"><span class="keyword">set</span>[Symbol.iterator]() //Iterator遍历器</span><br><span class="line"><span class="keyword">set</span>[Symbol.iterator]().next() //&#123;value: <span class="string">"red"</span>, <span class="attr">done</span>: <span class="literal">false</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Map</span></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">let</span> obj= &#123;<span class="attr">map</span>: <span class="string">'map'</span>&#125;;</span><br><span class="line">map.set(obj, <span class="string">'mapValue'</span>);</span><br><span class="line">map[<span class="built_in">Symbol</span>.iterator]().next()  &#123;<span class="attr">value</span>: <span class="built_in">Array</span>(<span class="number">2</span>), <span class="attr">done</span>: <span class="literal">false</span>&#125;</span><br></pre></td></tr></table></figure>

<h2 id="16、for…in-和for…of有什么区别？"><a href="#16、for…in-和for…of有什么区别？" class="headerlink" title="16、for…in 和for…of有什么区别？"></a>16、for…in 和for…of有什么区别？</h2><blockquote>
<p>如果看到问题十六，那么就很好回答。问题十六提到了ES6统一了遍历标准，制定了可遍历对象，那么用什么方法去遍历呢？答案就是用<code>for...of</code>。ES6规定，有所部署了载了<code>Iterator</code>接口的对象(可遍历对象)都可以通过<code>for...of</code>去遍历，而<code>for..in</code>仅仅可以遍历对象</p>
</blockquote>
<ul>
<li>这也就意味着，数组也可以用<code>for...of</code>遍历，这极大地方便了数组的取值，且避免了很多程序用<code>for..in</code>去遍历数组的恶习</li>
</ul>
<h2 id="17、Generator函数是什么，有什么作用？"><a href="#17、Generator函数是什么，有什么作用？" class="headerlink" title="17、Generator函数是什么，有什么作用？"></a>17、Generator函数是什么，有什么作用？</h2><ul>
<li>如果说<code>JavaScript</code>是<code>ECMAScript</code>标准的一种具体实现、<code>Iterator</code>遍历器是<code>Iterator</code>的具体实现，那么<code>Generator</code>函数可以说是<code>Iterator</code>接口的具体实现方式。</li>
<li>执行<code>Generator</code>函数会返回一个遍历器对象，每一次<code>Generator</code>函数里面的<code>yield</code>都相当一次遍历器对象的<code>next()</code>方法，并且可以通过<code>next(value)</code>方法传入自定义的value,来改变<code>Generator</code>函数的行为。</li>
<li><code>Generator</code>函数可以通过配合<code>Thunk</code> 函数更轻松更优雅的实现异步编程和控制流管理。</li>
</ul>
<h2 id="18、async函数是什么，有什么作用？"><a href="#18、async函数是什么，有什么作用？" class="headerlink" title="18、async函数是什么，有什么作用？"></a>18、async函数是什么，有什么作用？</h2><blockquote>
<p><code>async</code>函数可以理解为内置自动执行器的<code>Generator</code>函数语法糖，它配合<code>ES6</code>的<code>Promise</code>近乎完美的实现了异步编程解决方案</p>
</blockquote>
<h2 id="19、Class、extends是什么，有什么作用？"><a href="#19、Class、extends是什么，有什么作用？" class="headerlink" title="19、Class、extends是什么，有什么作用？"></a>19、Class、extends是什么，有什么作用？</h2><blockquote>
<p><code>ES6</code> 的<code>class</code>可以看作只是一个<code>ES5</code>生成实例对象的构造函数的语法糖。它参考了<code>java</code>语言，定义了一个类的概念，让对象原型写法更加清晰，对象实例化更像是一种面向对象编程。<code>Class</code>类可以通过<code>extends</code>实现继承。它和ES5构造函数的不同点</p>
</blockquote>
<p>类的内部定义的所有方法，都是不可枚举的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///ES5</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ES5Fun</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.x = x;</span><br><span class="line">	<span class="keyword">this</span>.y = y;</span><br><span class="line">&#125;</span><br><span class="line">ES5Fun.prototype.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	 <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> ES5Fun(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">p.toString();</span><br><span class="line"><span class="built_in">Object</span>.keys(ES5Fun.prototype); <span class="comment">//['toString']</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ES6</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ES6Fun</span> </span>&#123;</span><br><span class="line">	<span class="keyword">constructor</span> (x, y) &#123;</span><br><span class="line">		<span class="keyword">this</span>.x = x;</span><br><span class="line">		<span class="keyword">this</span>.y = y;</span><br><span class="line">	&#125;</span><br><span class="line">	toString () &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(ES6Fun.prototype); <span class="comment">//[]</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>ES6</code>的<code>class</code>类必须用<code>new</code>命令操作，而<code>ES5</code>的构造函数不用<code>new</code>也可以执行。</li>
<li><code>ES6</code>的<code>class</code>类不存在变量提升，必须先定义<code>class</code>之后才能实例化，不像<code>ES5</code>中可以将构造函数写在实例化之后。</li>
<li><code>ES5</code> 的继承，实质是先创造子类的实例对象<code>this</code>，然后再将父类的方法添加到<code>this</code>上面。<code>ES6</code> 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到<code>this</code>上面（所以必须先调用<code>super</code>方法），然后再用子类的构造函数修改<code>this</code>。</li>
</ul>
<h2 id="20、module、export、import是什么，有什么作用？"><a href="#20、module、export、import是什么，有什么作用？" class="headerlink" title="20、module、export、import是什么，有什么作用？"></a>20、module、export、import是什么，有什么作用？</h2><ul>
<li><code>module</code>、<code>export</code>、<code>import</code>是<code>ES6</code>用来统一前端模块化方案的设计思路和实现方案。<code>export</code>、<code>import</code>的出现统一了前端模块化的实现方案，整合规范了浏览器/服务端的模块化方法，用来取代传统的<code>AMD/CMD</code>、<code>requireJS</code>、<code>seaJS</code>、<code>commondJS</code>等等一系列前端模块不同的实现方案，使前端模块化更加统一规范，<code>JS</code>也能更加能实现大型的应用程序开发。</li>
<li><code>import</code>引入的模块是静态加载（编译阶段加载）而不是动态加载（运行时加载）。</li>
<li><code>import</code>引入<code>export</code>导出的接口值是动态绑定关系，即通过该接口，可以取到模块内部实时的值</li>
</ul>
<h2 id="21、日常前端代码开发中，有哪些值得用ES6去改进的编程优化或者规范？"><a href="#21、日常前端代码开发中，有哪些值得用ES6去改进的编程优化或者规范？" class="headerlink" title="21、日常前端代码开发中，有哪些值得用ES6去改进的编程优化或者规范？"></a>21、日常前端代码开发中，有哪些值得用ES6去改进的编程优化或者规范？</h2><ul>
<li>常用箭头函数来取代<code>var self = this</code>;的做法。</li>
<li>常用<code>let</code>取代<code>var</code>命令。</li>
<li>常用数组/对象的结构赋值来命名变量，结构更清晰，语义更明确，可读性更好。</li>
<li>在长字符串多变量组合场合，用模板字符串来取代字符串累加，能取得更好地效果和阅读体验。</li>
<li>用<code>Class</code>类取代传统的构造函数，来生成实例化对象。</li>
<li>在大型应用开发中，要保持<code>module</code>模块化开发思维，分清模块之间的关系，常用<code>import</code>、<code>export</code>方法。</li>
</ul>
<h2 id="22、ES6的了解"><a href="#22、ES6的了解" class="headerlink" title="22、ES6的了解"></a>22、ES6的了解</h2><blockquote>
<p>新增模板字符串（为JavaScript提供了简单的字符串插值功能）、箭头函数（操作符左边为输入的参数，而右边则是进行的操作以及返回的值Inputs=&gt;outputs。）、for-of（用来遍历数据—例如数组中的值。）arguments对象可被不定参数和默认参数完美代替。ES6将promise对象纳入规范，提供了原生的Promise对象。增加了let和const命令，用来声明变量。增加了块级作用域。let命令实际上就增加了块级作用域。ES6规定，var命令和function命令声明的全局变量，属于全局对象的属性；let命令、const命令、class命令声明的全局变量，不属于全局对象的属性。。还有就是引入module模块的概念</p>
</blockquote>
<h2 id="23、说说你对Promise的理解"><a href="#23、说说你对Promise的理解" class="headerlink" title="23、说说你对Promise的理解"></a>23、说说你对Promise的理解</h2><ul>
<li><p>依照 Promise/A+ 的定义，Promise 有四种状态：</p>
<ul>
<li><p>pending: 初始状态, 非 fulfilled 或 rejected.</p>
</li>
<li><p>fulfilled: 成功的操作.</p>
</li>
<li><p>rejected: 失败的操作.</p>
</li>
<li><p>settled: Promise已被fulfilled或rejected，且不是pending</p>
</li>
</ul>
</li>
<li><p>另外， fulfilled 与 rejected 一起合称 settled</p>
</li>
<li><p>Promise 对象用来进行延迟(deferred) 和异步(asynchronous ) 计算</p>
</li>
</ul>
<h2 id="24、Promise-的构造函数"><a href="#24、Promise-的构造函数" class="headerlink" title="24、Promise 的构造函数"></a>24、Promise 的构造函数</h2><ul>
<li>构造一个 Promise，最基本的用法如下：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (...) &#123;  <span class="comment">// succeed</span></span><br><span class="line"></span><br><span class="line">            resolve(result);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;   <span class="comment">// fails</span></span><br><span class="line"></span><br><span class="line">            reject(<span class="built_in">Error</span>(errMessage));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Promise 实例拥有 then 方法（具有 then 方法的对象，通常被称为thenable）。它的使用方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promise.then(onFulfilled, onRejected)</span><br></pre></td></tr></table></figure>
</li>
<li><p>接收两个函数作为参数，一个在 fulfilled 的时候被调用，一个在rejected的时候被调用，接收参数就是 future，onFulfilled 对应 resolve, onRejected 对应 reject</p>
</li>
</ul>
<p><strong>什么是 Promise ？</strong></p>
<ul>
<li>Promise 就是一个对象，用来表示并传递异步操作的最终结果</li>
<li>Promise 最主要的交互方式：将回调函数传入 then 方法来获得最终结果或出错原因</li>
<li>Promise 代码书写上的表现：以“链式调用”代替回调函数层层嵌套（回调地狱）</li>
</ul>
<h2 id="25、谈一谈你了解ECMAScript6的新特性？"><a href="#25、谈一谈你了解ECMAScript6的新特性？" class="headerlink" title="25、谈一谈你了解ECMAScript6的新特性？"></a>25、谈一谈你了解ECMAScript6的新特性？</h2><ul>
<li>块级作用区域              <code>let a = 1;</code></li>
<li>可定义常量                <code>const PI = 3.141592654;</code></li>
<li>变量解构赋值              <code>var [a, b, c] = [1, 2, 3];</code></li>
<li>字符串的扩展(模板字符串)  <code>var sum =</code>${a + b}<code>;</code></li>
<li>数组的扩展(转换数组类型)   <code>Array.from($(&#39;li&#39;));</code></li>
<li>函数的扩展(扩展运算符)     <code>[1, 2].push(...[3, 4, 5]);</code></li>
<li>对象的扩展(同值相等算法)   <code>Object.is(NaN, NaN);</code></li>
<li>新增数据类型(Symbol)      <code>let uid = Symbol(&#39;uid&#39;);</code></li>
<li>新增数据结构(Map)        <code>let set = new Set([1, 2, 2, 3]);</code></li>
<li>for…of循环            <code>for(let val of arr){};</code></li>
<li>Promise对象            <code>var promise = new Promise(func);</code></li>
<li>Generator函数          <code>function* foo(x){yield x; return x*x;}</code></li>
<li>引入Class(类)          <code>class Foo {}</code></li>
<li>引入模块体系            <code>export default func;</code></li>
<li>引入async函数[ES7]    </li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncPrint</span>(<span class="params">value, ms</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">await</span> timeout(ms);</span><br><span class="line">      <span class="built_in">console</span>.log(value)</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<h2 id="26、Object-is-与原来的比较操作符-、-的区别？"><a href="#26、Object-is-与原来的比较操作符-、-的区别？" class="headerlink" title="26、Object.is() 与原来的比较操作符 ===、== 的区别？"></a>26、Object.is() 与原来的比较操作符 ===、== 的区别？</h2><ul>
<li>== 相等运算符，比较时会自动进行数据类型转换</li>
<li>=== 严格相等运算符，比较时不进行隐式类型转换</li>
<li>Object.is 同值相等算法，在 === 基础上对 0 和 NaN 特别处理</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+0 === -0 //true</span><br><span class="line">NaN === NaN // false</span><br><span class="line"></span><br><span class="line">Object.is(+0, -0) // false</span><br><span class="line">Object.is(NaN, NaN) // true</span><br></pre></td></tr></table></figure>

<h2 id="27、什么是-Babel"><a href="#27、什么是-Babel" class="headerlink" title="27、什么是 Babel"></a>27、什么是 Babel</h2><ul>
<li>Babel 是一个 JS 编译器，自带一组 ES6 语法转化器，用于转化 JS 代码。<br>这些转化器让开发者提前使用最新的 JS语法(ES6/ES7)，而不用等浏览器全部兼容。</li>
<li>Babel 默认只转换新的 JS 句法(syntax)，而不转换新的API。</li>
</ul>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  
  
  

</article>
    
    <article id="post-DOM事件的总结" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    

    
    <div class="article-meta">
      <a href="/2020/04/16/DOM事件的总结/" class="article-date">
  <time datetime="2020-04-15T17:36:59.958Z" itemprop="datePublished">2020-04-16</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <p><strong>知识点主要包括以下几个方面：</strong></p>
<ul>
<li>基本概念：<code>DOM</code>事件的级别</li>
</ul>
<blockquote>
<p>面试不会直接问你，DOM有几个级别。但会在题目中体现：“请用<code>DOM2</code> ….”。</p>
</blockquote>
<ul>
<li><code>DOM</code>事件模型、<code>DOM</code>事件流</li>
</ul>
<blockquote>
<p>面试官如果问你“<strong>DOM事件模型</strong>”，你不一定知道怎么回事。其实说的就是<strong>捕获和冒泡</strong>。</p>
</blockquote>
<p><strong>DOM事件流</strong>，指的是事件传递的<strong>三个阶段</strong>。</p>
<ul>
<li>描述<code>DOM</code>事件捕获的具体流程</li>
</ul>
<blockquote>
<p>讲的是事件的传递顺序。参数为<code>false</code>（默认）、参数为<code>true</code>，各自代表事件在什么阶段触发。</p>
</blockquote>
<p>能回答出来的人，寥寥无几。也许有些人可以说出一大半，但是一字不落的人，极少。</p>
<ul>
<li><code>Event</code>对象的常见应用（<code>Event</code>的常用<code>api</code>方法）</li>
</ul>
<blockquote>
<p><code>DOM</code>事件的知识点，一方面包括事件的流程；另一方面就是：怎么去注册事件，也就是监听用户的交互行为。第三点：在响应时，<code>Event</code>对象是非常重要的。</p>
</blockquote>
<p><strong>自定义事件（非常重要）</strong></p>
<blockquote>
<p>一般人可以讲出事件和注册事件，但是如果让你讲<strong>自定义事件</strong>，能知道的人，就更少了。</p>
</blockquote>
<p><strong>DOM事件的级别</strong></p>
<blockquote>
<p><code>DOM</code>事件的级别，准确来说，是<strong>DOM标准</strong>定义的级别。包括：</p>
</blockquote>
<p><strong>DOM0的写法：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">element.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面的代码是在 <code>js</code> 中的写法；如果要在<code>html</code>中写，写法是：在<code>onclick</code>属性中，加 <code>js</code> 语句。</p>
</blockquote>
<p><strong>DOM2的写法：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">element.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>【重要】上面的第三参数中，<strong>true</strong>表示事件在<strong>捕获阶段</strong>触发，<strong>false</strong>表示事件在<strong>冒泡阶段</strong>触发（默认）。如果不写，则默认为false。</p>
</blockquote>
<p><strong>DOM3的写法：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">element.addEventListener(<span class="string">'keyup'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>DOM3</code>中，增加了很多事件类型，比如鼠标事件、键盘事件等。</p>
</blockquote>
<blockquote>
<p>PS：为何事件没有<code>DOM1</code>的写法呢？因为，<code>DOM1</code>标准制定的时候，没有涉及与事件相关的内容。</p>
</blockquote>
<p><strong>总结</strong>：关于“DOM事件的级别”，能回答出以上内容即可，不会出题目让你做。</p>
<p><strong>DOM事件模型</strong></p>
<blockquote>
<p><code>DOM</code>事件模型讲的就是<strong>捕获和冒泡</strong>，一般人都能回答出来。</p>
</blockquote>
<ul>
<li>捕获：从上往下。</li>
<li>冒泡：从下（目标元素）往上。</li>
</ul>
<p><strong>DOM事件流</strong></p>
<blockquote>
<p><code>DOM</code>事件流讲的就是：浏览器在于当前页面做交互时，这个事件是怎么传递到页面上的。</p>
</blockquote>
<p><strong>完整的事件流，分三个阶段：</strong></p>
<ol>
<li>捕获：从 <code>window</code> 对象传到 目标元素。</li>
<li>目标阶段：事件通过捕获，到达目标元素，这个阶段就是目标阶段。</li>
<li>冒泡：从<strong>目标元素</strong>传到 <code>Window</code> 对象。</li>
</ol>
<p><img src="http://img.smyhvae.com/20180306_1058.png" alt></p>
<p><img src="http://img.smyhvae.com/20180204_1218.jpg" alt></p>
<p><strong>描述DOM事件捕获的具体流程</strong></p>
<blockquote>
<p>很少有人能说完整。</p>
</blockquote>
<p><strong>捕获的流程</strong></p>
<p><img src="http://img.smyhvae.com/20180306_1103.png" alt></p>
<p><strong>说明</strong>：捕获阶段，事件依次传递的顺序是：<code>window</code> –&gt; <code>document</code> –&gt; <code>html</code>–&gt; <code>body</code> –&gt; 父元素、子元素、目标元素。</p>
<ul>
<li>PS1：第一个接收到事件的对象是 <strong>window</strong>（有人会说<code>body</code>，有人会说<code>html</code>，这都是错误的）。</li>
<li>PS2：<code>JS</code>中涉及到<code>DOM</code>对象时，有两个对象最常用：<code>window</code>、<code>doucument</code>。它们俩也是最先获取到事件的。</li>
</ul>
<p>代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">"捕获 window"</span>);</span><br><span class="line">&#125;, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">"捕获 document"</span>);</span><br><span class="line">&#125;, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.documentElement.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">"捕获 html"</span>);</span><br><span class="line">&#125;, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">"捕获 body"</span>);</span><br><span class="line">&#125;, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">fatherBox.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">"捕获 father"</span>);</span><br><span class="line">&#125;, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">childBox.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">"捕获 child"</span>);</span><br><span class="line">&#125;, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<p><strong>补充一个知识点：</strong></p>
<blockquote>
<p>在 <code>js</code>中：</p>
</blockquote>
<ul>
<li>如果想获取 <code>body</code> 节点，方法是：<code>document.body</code>；</li>
<li>但是，如果想获取 <code>html</code>节点，方法是<code>document.documentElement</code>。</li>
</ul>
<p><strong>冒泡的流程</strong></p>
<blockquote>
<p>与捕获的流程相反</p>
</blockquote>
<p><strong>Event对象的常见 api 方法</strong></p>
<blockquote>
<p>用户做的是什么操作（比如，是敲键盘了，还是点击鼠标了），这些事件基本都是通过<code>Event</code>对象拿到的。这些都比较简单，我们就不讲了。我们来看看下面这几个方法：</p>
</blockquote>
<p><strong>方法一</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event.preventDefault();</span><br></pre></td></tr></table></figure>

<ul>
<li>解释：阻止默认事件。</li>
<li>比如，已知<code>&lt;a&gt;</code>标签绑定了click事件，此时，如果给<code>&lt;a&gt;</code>设置了这个方法，就阻止了链接的默认跳转。</li>
</ul>
<p><strong>方法二：阻止冒泡</strong></p>
<blockquote>
<p>这个在业务中很常见。</p>
</blockquote>
<blockquote>
<p>有的时候，业务中不需要事件进行冒泡。比如说，业务这样要求：单击子元素做事件<code>A</code>，单击父元素做事件B，如果不阻止冒泡的话，出现的问题是：单击子元素时，子元素和父元素都会做事件<code>A</code>。这个时候，就要用到阻止冒泡了。</p>
</blockquote>
<blockquote>
<p><code>w3c</code>的方法：（火狐、谷歌、<code>IE11</code>）</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event.stopPropagation();</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>IE10</code>以下则是：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event.cancelBubble = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>兼容代码如下：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">box3.onclick = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">     alert(<span class="string">"child"</span>);</span><br><span class="line"></span><br><span class="line">     <span class="comment">//阻止冒泡</span></span><br><span class="line">     event = event || <span class="built_in">window</span>.event;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (event &amp;&amp; event.stopPropagation) &#123;</span><br><span class="line">         event.stopPropagation();</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         event.cancelBubble = <span class="literal">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上方代码中，我们对<code>box3</code>进行了阻止冒泡，产生的效果是：事件不会继续传递到 <code>father</code>、<code>grandfather</code>、<code>body</code>了。</p>
</blockquote>
<p><strong>方法三：设置事件优先级</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event.stopImmediatePropagation();</span><br></pre></td></tr></table></figure>

<p>这个方法比较长，一般人没听说过。解释如下：</p>
<blockquote>
<p>比如说，我用<code>addEventListener</code>给某按钮同时注册了事件<code>A</code>、事件<code>B</code>。此时，如果我单击按钮，就会依次执行事件A和事件<code>B</code>。现在要求：单击按钮时，只执行事件A，不执行事件<code>B</code>。该怎么做呢？这是时候，就可以用到<code>stopImmediatePropagation</code>方法了。做法是：在事件A的响应函数中加入这句话。</p>
</blockquote>
<blockquote>
<p>大家要记住 <code>event</code> 有这个方法。</p>
</blockquote>
<p><strong>属性4、属性5（事件委托中用到）</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">event.currentTarget   <span class="comment">//当前所绑定的事件对象。在事件委托中，指的是【父元素】。</span></span><br><span class="line"></span><br><span class="line">event.target  <span class="comment">//当前被点击的元素。在事件委托中，指的是【子元素】。</span></span><br></pre></td></tr></table></figure>

<p>上面这两个属性，在事件委托中经常用到。</p>
<blockquote>
<p><strong>总结</strong>：上面这几项，非常重要，但是容易弄混淆。</p>
</blockquote>
<p><strong>自定义事件</strong></p>
<blockquote>
<p>自定义事件的代码如下：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">var</span> myEvent = <span class="keyword">new</span> Event(<span class="string">'clickTest'</span>);</span><br><span class="line">   element.addEventListener(<span class="string">'clickTest'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">'smyhvae'</span>);</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//元素注册事件</span></span><br><span class="line">   element.dispatchEvent(myEvent); <span class="comment">//注意，参数是写事件对象 myEvent，不是写 事件名 clickTest</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面这个事件是定义完了之后，就直接自动触发了。在正常的业务中，这个事件一般是和别的事件结合用的。比如延时器设置按钮的动作：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myEvent = <span class="keyword">new</span> Event(<span class="string">'clickTest'</span>);</span><br><span class="line"></span><br><span class="line">element.addEventListener(<span class="string">'clickTest'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'smyhvae'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    element.dispatchEvent(myEvent); <span class="comment">//注意，参数是写事件对象 myEvent，不是写 事件名 clickTest</span></span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>


      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  
  
  

</article>
    
    <article id="post-data-structure" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    

    
    <div class="article-meta">
      <a href="/2020/04/16/data-structure/" class="article-date">
  <time datetime="2020-04-15T17:36:59.944Z" itemprop="datePublished">2020-04-16</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <p><strong>栈和队列的区别?</strong></p>
<ul>
<li>栈的插入和删除操作都是在一端进行的，而队列的操作却是在两端进行的。</li>
<li>队列先进先出，栈先进后出。</li>
<li>栈只允许在表尾一端进行插入和删除，而队列只允许在表尾一端进行插入，在表头一端进行删除</li>
</ul>
<p><strong>栈和堆的区别？</strong></p>
<ul>
<li>栈区（stack）—   由编译器自动分配释放   ，存放函数的参数值，局部变量的值等。</li>
<li>堆区（heap）   —   一般由程序员分配释放，   若程序员不释放，程序结束时可能由OS回收。</li>
<li>堆（数据结构）：堆可以被看成是一棵树，如：堆排序；</li>
<li>栈（数据结构）：一种先进后出的数据结构</li>
</ul>
<p><strong>快速 排序的思想并实现一个快排？</strong></p>
<p>“快速排序”的思想很简单，整个排序过程只需要三步：</p>
<ul>
<li>（1）在数据集之中，找一个基准点</li>
<li>（2）建立两个数组，分别存储左边和右边的数组</li>
<li>（3）利用递归进行下次比较</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr.length&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> arr;<span class="comment">//如果数组只有一个数，就直接返回；</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> num = <span class="built_in">Math</span>.floor(arr.length/<span class="number">2</span>);<span class="comment">//找到中间数的索引值，如果是浮点数，则向下取整</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> numValue = arr.splice(num,<span class="number">1</span>);<span class="comment">//找到中间数的值</span></span><br><span class="line">    <span class="keyword">var</span> left = [];</span><br><span class="line">    <span class="keyword">var</span> right = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i]&lt;numValue)&#123;</span><br><span class="line">            left.push(arr[i]);<span class="comment">//基准点的左边的数传到左边数组</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">           right.push(arr[i]);<span class="comment">//基准点的右边的数传到右边数组</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> quickSort(left).concat([numValue],quickSort(right));<span class="comment">//递归不断重复比较</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert(quickSort([<span class="number">32</span>,<span class="number">45</span>,<span class="number">37</span>,<span class="number">16</span>,<span class="number">2</span>,<span class="number">87</span>]));<span class="comment">//弹出“2,16,32,37,45,87”</span></span><br></pre></td></tr></table></figure>


      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  
  
  

</article>
    
    <article id="post-dataBase" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    

    
    <div class="article-meta">
      <a href="/2020/04/16/dataBase/" class="article-date">
  <time datetime="2020-04-15T17:36:59.940Z" itemprop="datePublished">2020-04-16</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <p><strong>说说mongoDB和MySQL的区别</strong></p>
<ul>
<li><code>MySQL</code>是传统的关系型数据库，MongoDB则是非关系型数据库</li>
<li><code>mongodb</code>以BSON结构（二进制）进行存储，对海量数据存储有着很明显的优势。</li>
<li>对比传统关系型数据库,NoSQL有着非常显著的性能和扩展性优势，与关系型数据库相比，MongoDB的优点有： ①弱一致性（最终一致），更能保证用户的访问速度： ②文档结构的存储方式，能够更便捷的获取数据</li>
</ul>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  
  
  

</article>
    
    <article id="post-CSS盒模型及BFC" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    

    
    <div class="article-meta">
      <a href="/2020/04/16/CSS盒模型及BFC/" class="article-date">
  <time datetime="2020-04-15T17:36:59.924Z" itemprop="datePublished">2020-04-16</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h2 id="题目：谈一谈你对CSS盒模型的认识"><a href="#题目：谈一谈你对CSS盒模型的认识" class="headerlink" title="题目：谈一谈你对CSS盒模型的认识"></a>题目：谈一谈你对CSS盒模型的认识</h2><blockquote>
<p>专业的面试，一定会问 <code>CSS</code> 盒模型。对于这个题目，我们要回答一下几个方面：</p>
</blockquote>
<ol>
<li>基本概念：<code>content</code>、<code>padding</code>、<code>margin</code></li>
<li>标准盒模型、<code>IE</code>盒模型的区别。不要漏说了<code>IE</code>盒模型，通过这个问题，可以筛选一部分人</li>
<li><code>CSS</code>如何设置这两种模型（即：如何设置某个盒子为其中一个模型）？如果回答了上面的第二条，还会继续追问这一条。</li>
<li><code>JS</code>如何设置、获取盒模型对应的宽和高？这一步，已经有很多人答不上来了。</li>
<li>实例题：根据盒模型解释<strong>边距重叠</strong>。</li>
</ol>
<blockquote>
<p>前四个方面是逐渐递增，第五个方面，却鲜有人知。</p>
</blockquote>
<ol start="6">
<li><code>BFC</code>（边距重叠解决方案）或<code>IFC</code>。</li>
</ol>
<blockquote>
<p>如果能回答第五条，就会引出第六条。<code>BFC</code>是面试频率较高的。</p>
</blockquote>
<p><strong>总结</strong>：以上几点，从上到下，知识点逐渐递增，知识面从理论、<code>CSS</code>、<code>JS</code>，又回到<code>CSS</code>理论</p>
<p>接下来，我们把上面的六条，依次讲解。</p>
<p><strong>标准盒模型和IE盒子模型</strong></p>
<p>标准盒子模型：</p>
<p><img src="http://img.smyhvae.com/2015-10-03-css-27.jpg" alt></p>
<p><code>IE</code>盒子模型：</p>
<p><img src="http://img.smyhvae.com/2015-10-03-css-30.jpg" alt></p>
<p>上图显示：</p>
<blockquote>
<p>在 <code>CSS</code> 盒子模型 (<code>Box Model</code>) 规定了元素处理元素的几种方式：</p>
</blockquote>
<ul>
<li><code>width</code>和<code>height</code>：<strong>内容</strong>的宽度、高度（不是盒子的宽度、高度）。</li>
<li><code>padding</code>：内边距。</li>
<li><code>border</code>：边框。</li>
<li><code>margin</code>：外边距。</li>
</ul>
<blockquote>
<p><code>CSS</code>盒模型和<code>IE</code>盒模型的区别：</p>
</blockquote>
<ul>
<li><p>在<strong>标准盒子模型</strong>中，<strong>width 和 height 指的是内容区域</strong>的宽度和高度。增加内边距、边框和外边距不会影响内容区域的尺寸，但是会增加元素框的总尺寸。</p>
</li>
<li><p><strong>IE盒子模型</strong>中，<strong>width 和 height 指的是内容区域+border+padding</strong>的宽度和高度。</p>
</li>
</ul>
<p><strong>CSS如何设置这两种模型</strong></p>
<p>代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 设置当前盒子为 标准盒模型（默认） */</span></span><br><span class="line">box-sizing: content-box;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置当前盒子为 IE盒模型 */</span></span><br><span class="line">box-sizing: border-box;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>备注：盒子默认为标准盒模型。</p>
</blockquote>
<p><strong>JS如何设置、获取盒模型对应的宽和高</strong></p>
<blockquote>
<p>方式一：通过<code>DOM</code>节点的 <code>style</code> 样式获取</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.style.width/height;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>缺点：通过这种方式，只能获取<strong>行内样式</strong>，不能获取<code>内嵌</code>的样式和<code>外链</code>的样式。</p>
</blockquote>
<p>这种方式有局限性，但应该了解。</p>
<blockquote>
<p>方式二（通用型）</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.getComputedStyle(element).width/height;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>方式二能兼容 <code>Chrome</code>、火狐。是通用型方式。</p>
</blockquote>
<blockquote>
<p>方式三（IE独有的）</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.currentStyle.width/height;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>和方式二相同，但这种方式只有IE独有。获取到的即时运行完之后的宽高（三种css样式都可以获取）。</p>
</blockquote>
<blockquote>
<p>方式四</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.getBoundingClientRect().width/height;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>此 <code>api</code> 的作用是：获取一个元素的绝对位置。绝对位置是视窗 <code>viewport</code> 左上角的绝对位置。此 <code>api</code> 可以拿到四个属性：<code>left</code>、<code>top</code>、<code>width</code>、<code>height</code>。</p>
</blockquote>
<p><strong>总结：</strong></p>
<blockquote>
<p>上面的四种方式，要求能说出来区别，以及哪个的通用型更强。</p>
</blockquote>
<p><strong>margin塌陷/margin重叠</strong></p>
<p><strong>标准文档流中，竖直方向的margin不叠加，只取较大的值作为margin</strong>(水平方向的<code>margin</code>是可以叠加的，即水平方向没有塌陷现象)。</p>
<blockquote>
<p>PS：如果不在标准流，比如盒子都浮动了，那么两个盒子之间是没有<code>margin</code>重叠的现象的。</p>
</blockquote>
<blockquote>
<p>我们来看几个例子。</p>
</blockquote>
<p><strong>兄弟元素之间</strong></p>
<p>如下图所示：</p>
<p><img src="http://img.smyhvae.com/20170805_0904.png" alt></p>
<p><strong>子元素和父元素之间</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        * &#123;</span><br><span class="line">            margin: 0;</span><br><span class="line">            padding: 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.father</span> &#123;</span></span><br><span class="line">            background: green;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="comment">/* 给儿子设置margin-top为10像素 */</span></span></span><br><span class="line"><span class="css">        <span class="selector-class">.son</span> &#123;</span></span><br><span class="line">            height: 100px;</span><br><span class="line">            margin-top: 10px;</span><br><span class="line">            background: red;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"father"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"son"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面的代码中，儿子的<code>height</code>是 <code>100p</code>x，<code>magin-top</code> 是<code>10px</code>。注意，此时父亲的 <code>height</code> 是<code>100</code>，而不是<code>110</code>。因为儿子和父亲在竖直方向上，共一个<code>margin</code>。</p>
</blockquote>
<p>儿子这个盒子：</p>
<p><img src="http://img.smyhvae.com/20180305_2216.png" alt></p>
<p>父亲这个盒子：</p>
<p><img src="http://img.smyhvae.com/20180305_2217.png" alt></p>
<blockquote>
<p>上方代码中，如果我们给父亲设置一个属性：<code>overflow: hidden</code>，就可以避免这个问题，此时父亲的高度是110px，这个用到的就是BFC（下一段讲解）。</p>
</blockquote>
<p><strong>善于使用父亲的padding，而不是儿子的margin</strong></p>
<blockquote>
<p>其实，这一小段讲的内容与上一小段相同，都是讲父子之间的margin重叠。</p>
</blockquote>
<p>我们来看一个奇怪的现象。现在有下面这样一个结构：（<code>div</code>中放一个<code>p</code>）</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面的结构中，我们尝试通过给儿子<code>p</code>一个<code>margin-top:50px;</code>的属性，让其与父亲保持50px的上边距。结果却看到了下面的奇怪的现象：</p>
</blockquote>
<p><img src="http://img.smyhvae.com/20170806_1537.png" alt></p>
<blockquote>
<p>此时我们给父亲<code>div</code>加一个<code>border</code>属性，就正常了：</p>
</blockquote>
<p><img src="http://img.smyhvae.com/20170806_1544.png" alt></p>
<blockquote>
<p>如果父亲没有<code>border</code>，那么儿子的<code>margin</code>实际上踹的是“流”，踹的是这“行”。所以，父亲整体也掉下来了。</p>
</blockquote>
<p><strong>margin这个属性，本质上描述的是兄弟和兄弟之间的距离； 最好不要用这个marign表达父子之间的距离。</strong></p>
<blockquote>
<p>所以，如果要表达父子之间的距离，我们一定要善于使用父亲的padding，而不是儿子的`margin。</p>
</blockquote>
<p><strong>BFC（边距重叠解决方案）</strong></p>
<blockquote>
<p><code>BFC（Block Formatting Context）</code>：块级格式化上下文。你可以把它理解成一个独立的区域。</p>
</blockquote>
<p>另外还有个概念叫<code>IFC</code>。不过，<code>BFC</code>问得更多。</p>
<p><strong>BFC 的原理/BFC的布局规则【非常重要】</strong></p>
<blockquote>
<p><code>BFC</code> 的原理，其实也就是 <code>BFC</code> 的渲染规则（能说出以下四点就够了）。包括：</p>
</blockquote>
<ol>
<li>BFC <strong>内部的</strong>子元素，在垂直方向，<strong>边距会发生重叠</strong>。</li>
<li>BFC在页面中是独立的容器，外面的元素不会影响里面的元素，反之亦然。（稍后看<code>举例1</code>）</li>
<li><strong>BFC区域不与旁边的<code>float box</code>区域重叠</strong>。（可以用来清除浮动带来的影响）。（稍后看<code>举例2</code>）</li>
<li>计算<code>BFC</code>的高度时，浮动的子元素也参与计算。（稍后看<code>举例3</code>）</li>
</ol>
<p><strong>如何生成BFC</strong></p>
<blockquote>
<p>有以下几种方法：</p>
</blockquote>
<ul>
<li>方法1：<code>overflow</code>: 不为<code>visible</code>，可以让属性是 <code>hidden</code>、<code>auto</code>。【最常用】</li>
<li>方法2：浮动中：<code>float</code>的属性值不为<code>none</code>。意思是，只要设置了浮动，当前元素就创建了<code>BFC</code>。</li>
<li>方法3：定位中：只要<code>posiiton</code>的值不是 s<code>tatic</code>或者是<code>relative</code>即可，可以是<code>absolute</code>或<code>fixed</code>，也就生成了一个<code>BFC</code>。</li>
<li>方法4：<code>display</code>为<code>inline-block</code>, <code>table-cell</code>, <code>table-caption</code>, <code>flex</code>, <code>inline-flex</code></li>
</ul>
<p><strong>BFC 的应用</strong></p>
<p><strong>举例1：</strong>解决 margin 重叠</p>
<blockquote>
<p>当父元素和子元素发生 <code>margin</code> 重叠时，解决办法：<strong>给子元素或父元素创建BFC</strong>。</p>
</blockquote>
<p>比如说，针对下面这样一个 <code>div</code> 结构：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"father"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"son"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面的<code>div</code>结构中，如果父元素和子元素发生<code>margin</code>重叠，我们可以给子元素创建一个 <code>BFC</code>，就解决了：</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"father"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"son"</span> <span class="attr">style</span>=<span class="string">"overflow: hidden"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>因为<strong>第二条：BFC区域是一个独立的区域，不会影响外面的元素</strong>。</p>
</blockquote>
<p><strong>举例2</strong>：BFC区域不与float区域重叠：</p>
<p>针对下面这样一个div结构；</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.father-layout</span> &#123;</span></span><br><span class="line">            background: pink;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.father-layout</span> <span class="selector-class">.left</span> &#123;</span></span><br><span class="line">            float: left;</span><br><span class="line">            width: 100px;</span><br><span class="line">            height: 100px;</span><br><span class="line">            background: green;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.father-layout</span> <span class="selector-class">.right</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">height</span>: 150<span class="selector-tag">px</span>;  <span class="comment">/*右侧标准流里的元素，比左侧浮动的元素要高*/</span></span></span><br><span class="line">            background: red;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"father-layout"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span></span><br><span class="line">        左侧，生命壹号</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span></span><br><span class="line">        右侧，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img src="http://img.smyhvae.com/20180306_0825.png" alt></p>
<blockquote>
<p>上图中，由于右侧标准流里的元素，比左侧浮动的元素要高，导致右侧有一部分会跑到左边的下面去。</p>
</blockquote>
<p><strong>如果要解决这个问题，可以将右侧的元素创建BFC</strong>，因为<strong>第三条：BFC区域不与<code>float box</code>区域重叠</strong>。解决办法如下：（将right区域添加overflow属性）</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span> <span class="attr">style</span>=<span class="string">"overflow: hidden"</span>&gt;</span></span><br><span class="line">    右侧，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="http://img.smyhvae.com/20180306_0827.png" alt></p>
<p>上图表明，解决之后，<code>father-layout</code>的背景色显现出来了，说明问题解决了。</p>
<p><strong>举例3：</strong>清除浮动</p>
<p>现在有下面这样的结构：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.father</span> &#123;</span></span><br><span class="line">            background: pink;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.son</span> &#123;</span></span><br><span class="line">            float: left;</span><br><span class="line">            background: green;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"father"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"son"</span>&gt;</span></span><br><span class="line">        生命壹号</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img src="http://img.smyhvae.com/20180306_0840.png" alt></p>
<p>上面的代码中，儿子浮动了，但由于父亲没有设置高度，导致看不到父亲的背景色（此时父亲的高度为0）。正所谓<strong>有高度的盒子，才能关住浮动</strong>。</p>
<blockquote>
<p>如果想要清除浮动带来的影响，方法一是给父亲设置高度，然后采用隔墙法。方法二是 BFC：给父亲增加 <code>overflow=hidden</code>属性即可， 增加之后，效果如下：</p>
</blockquote>
<p><img src="http://img.smyhvae.com/20180306_0845.png" alt></p>
<blockquote>
<p>为什么父元素成为BFC之后，就有了高度呢？这就回到了<strong>第四条：计算BFC的高度时，浮动元素也参与计算</strong>。意思是，<strong>在计算BFC的高度时，子元素的float box也会参与计算</strong></p>
</blockquote>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  
  
  

</article>
    
    <article id="post-CSS" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    

    
    <div class="article-meta">
      <a href="/2020/04/16/CSS/" class="article-date">
  <time datetime="2020-04-15T17:36:59.914Z" itemprop="datePublished">2020-04-16</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><hr>
<p><strong>display: none; 与 visibility: hidden; 的区别</strong></p>
<ul>
<li>联系：它们都能让元素不可见</li>
<li>区别：<ul>
<li><code>display:none</code>;会让元素完全从渲染树中消失，渲染的时候不占据任何空间；<code>visibility: hidden</code>;不会让元素从渲染树消失，渲染师元素继续占据空间，只是内容不可见</li>
<li><code>display: none</code>;是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示；<code>visibility:hidden</code>;是继承属性，子孙节点消失由于继承了<code>hidden</code>，通过设置<code>visibility: visible</code>;可以让子孙节点显式</li>
<li>修改常规流中元素的<code>display</code>通常会造成文档重排。修改<code>visibility</code>属性只会造成本元素的重绘</li>
<li>读屏器不会读取<code>display: none;</code>元素内容；会读取<code>visibility: hidden</code>元素内容</li>
</ul>
</li>
</ul>
<p><strong>css hack原理及常用hack</strong></p>
<ul>
<li>原理：利用不同浏览器对CSS的支持和解析结果不一样编写针对特定浏览器样式。</li>
<li>常见的hack有<ul>
<li>属性hack</li>
<li>选择器hack</li>
<li>IE条件注释</li>
</ul>
</li>
</ul>
<p><strong>link 与 @import 的区别</strong></p>
<ul>
<li><code>link</code> 是<code>HTML</code>方式， <code>@import</code> 是<code>CSS</code>方式</li>
<li><code>link</code>最大限度支持并行下载，<code>@import</code> 过多嵌套导致串行下载，出现FOUC</li>
<li><code>link</code> 可以通过 <code>rel=&quot;alternate stylesheet&quot;</code> 指定候选样式</li>
<li>浏览器对 <code>link</code> 支持早于<code>@import</code> ，可以使用 <code>@import</code> 对老浏览器隐藏样式</li>
<li><code>@import</code> 必须在样式规则之前，可以在<code>css</code>文件中引用其他文件</li>
<li>总体来说：<code>link</code>优于<code>@import</code></li>
</ul>
<p><strong>CSS有哪些继承属性</strong></p>
<ul>
<li>关于文字排版的属性如：<ul>
<li><code>font</code><ul>
<li><code>word-break</code></li>
<li><code>letter-spacing</code></li>
<li><code>text-align</code></li>
<li><code>text-rendering</code></li>
<li><code>word-spacing</code></li>
<li><code>white-space</code></li>
<li><code>text-indent</code></li>
<li><code>text-transform</code></li>
<li><code>text-shadow</code></li>
</ul>
</li>
<li><code>line-height</code></li>
<li><code>color</code></li>
<li><code>visibility</code></li>
<li><code>cursor</code></li>
</ul>
</li>
</ul>
<p><strong>display,float,position的关系</strong></p>
<ul>
<li><p>如果 <code>display</code> 为<code>none</code>，那么<code>position</code>和<code>float</code>都不起作用，这种情况下元素不产生框</p>
</li>
<li><p>否则，如果<code>position</code>值为<code>absolute</code>或者<code>fixed</code>，框就是绝对定位的，<code>float</code>的计算值为<code>none</code>，<code>display</code>根据下面的表格进行调整</p>
</li>
<li><p>否则，如果<code>float</code>不是<code>none</code>，框是浮动的，<code>display</code>根据下表进行调整</p>
</li>
<li><p>否则，如果元素是根元素，<code>display</code>根据下表进行调整</p>
</li>
<li><p>其他情况下<code>display</code>的值为指定值 总结起来：绝对定位、浮动、根元素都需要调整 <code>display</code></p>
<p><img src="https://images2018.cnblogs.com/blog/715962/201805/715962-20180513012245079-391725349.png" alt="图片转自网络"></p>
</li>
</ul>
<p><strong>外边距折叠(collapsing margins)</strong></p>
<ul>
<li>毗邻的两个或多个 <code>margin</code> 会合并成一个<code>margin</code>，叫做外边距折叠。规则如下：<ul>
<li>两个或多个毗邻的普通流中的块元素垂直方向上的<code>margin</code>会折叠</li>
<li>浮动元素或<code>inline-block</code>元素或绝对定位元素的<code>margin</code>不会和垂直方向上的其他元素的margin折叠</li>
<li>创建了块级格式化上下文的元素，不会和它的子元素发生margin折叠</li>
<li>元素自身的<code>margin-bottom</code>和<code>margin-top</code>相邻时也会折</li>
</ul>
</li>
</ul>
<p><strong>介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？</strong></p>
<ul>
<li>有两种， IE 盒子模型、W3C 盒子模型；</li>
<li>盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)；</li>
<li>区  别： IE的content部分把 border 和 padding计算了进去;</li>
</ul>
<p><strong>CSS选择符有哪些？哪些属性可以继承？</strong></p>
<ul>
<li><p>id选择器（ # myid）</p>
</li>
<li><p>类选择器（.myclassname）</p>
</li>
<li><p>标签选择器（div, h1, p）</p>
</li>
<li><p>相邻选择器（h1 + p）</p>
</li>
<li><p>子选择器（ul &gt; li）</p>
</li>
<li><p>后代选择器（li a）</p>
</li>
<li><p>通配符选择器（ * ）</p>
</li>
<li><p>属性选择器（a[rel = “external”]）</p>
</li>
<li><p>伪类选择器（a:hover, li:nth-child）</p>
</li>
<li><p>可继承的样式： <code>font-size font-family color, UL LI DL DD DT</code></p>
</li>
<li><p>不可继承的样式：<code>border padding margin width height</code></p>
</li>
</ul>
<p><strong>CSS优先级算法如何计算？</strong></p>
<ul>
<li>优先级就近原则，同权重情况下样式定义最近者为准</li>
<li>载入样式以最后载入的定位为准</li>
<li>优先级为: <code>!important &gt;  id &gt; class &gt; tag</code> important 比 内联优先级高</li>
</ul>
<p><strong>CSS3新增伪类有那些？</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">p:first-of-type 选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。</span><br><span class="line">p:last-of-type  选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。</span><br><span class="line">p:only-of-type  选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。</span><br><span class="line">p:only-child        选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。</span><br><span class="line">p:nth-child(2)  选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。</span><br><span class="line"></span><br><span class="line">:after          在元素之前添加内容,也可以用来做清除浮动。</span><br><span class="line">:before         在元素之后添加内容</span><br><span class="line">:enabled        </span><br><span class="line">:disabled       控制表单控件的禁用状态。</span><br><span class="line">:checked        单选框或复选框被选中</span><br></pre></td></tr></table></figure>

<p><strong>如何居中div？如何居中一个浮动元素？如何让绝对定位的div居中？</strong></p>
<ul>
<li>给<code>div</code>设置一个宽度，然后添加<code>margin:0 auto</code>属性</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">    width:200px;</span><br><span class="line">    margin:0 auto;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>居中一个浮动元素</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//确定容器的宽高 宽500 高 300 的层</span><br><span class="line">//设置层的外边距</span><br><span class="line"></span><br><span class="line"> .div &#123;</span><br><span class="line">      width:500px ; height:300px;//高度可以不设</span><br><span class="line">      margin: -150px 0 0 -250px;</span><br><span class="line">      position:relative;         //相对定位</span><br><span class="line">      background-color:pink;     //方便看效果</span><br><span class="line">      left:50%;</span><br><span class="line">      top:50%;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>让绝对定位的div居中</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">position: absolute;</span><br><span class="line">width: 1200px;</span><br><span class="line">background: none;</span><br><span class="line">margin: 0 auto;</span><br><span class="line">top: 0;</span><br><span class="line">left: 0;</span><br><span class="line">bottom: 0;</span><br><span class="line">right: 0;</span><br></pre></td></tr></table></figure>


<p><strong>display有哪些值？说明他们的作用</strong></p>
<ul>
<li>block         象块类型元素一样显示。</li>
<li>none          缺省值。象行内元素类型一样显示。</li>
<li>inline-block  象行内元素一样显示，但其内容象块类型元素一样显示。</li>
<li>list-item     象块类型元素一样显示，并添加样式列表标记。</li>
<li>table         此元素会作为块级表格来显示</li>
<li>inherit       规定应该从父元素继承 display 属性的值</li>
</ul>
<p><strong>position的值relative和absolute定位原点是？</strong></p>
<ul>
<li>absolute<ul>
<li>生成绝对定位的元素，相对于值不为 static的第一个父元素进行定位。</li>
</ul>
</li>
<li>fixed （老IE不支持）<ul>
<li>生成绝对定位的元素，相对于浏览器窗口进行定位。</li>
</ul>
</li>
<li>relative<ul>
<li>生成相对定位的元素，相对于其正常位置进行定位。</li>
</ul>
</li>
<li>static<ul>
<li>默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right - z-index 声明）。</li>
</ul>
</li>
<li>inherit<ul>
<li>规定从父元素继承 position 属性的值</li>
</ul>
</li>
</ul>
<p><strong>CSS3有哪些新特性？</strong></p>
<ul>
<li>新增各种CSS选择器  （: not(.input)：所有 class 不是“input”的节点）</li>
<li>圆角           （border-radius:8px）</li>
<li>多列布局        （multi-column layout）</li>
<li>阴影和反射        （Shadow\Reflect）</li>
<li>文字特效      （text-shadow、）</li>
<li>文字渲染      （Text-decoration）</li>
<li>线性渐变      （gradient）</li>
<li>旋转          （transform）</li>
<li>增加了旋转,缩放,定位,倾斜,动画，多背景</li>
<li><code>transform:\scale(0.85,0.90)\ translate(0px,-30px)\ skew(-9deg,0deg)\Animation:</code></li>
</ul>
<p><strong>用纯CSS创建一个三角形的原理是什么？</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 把上、左、右三条边隐藏掉（颜色设为 transparent）</span><br><span class="line">#demo &#123;</span><br><span class="line">  width: 0;</span><br><span class="line">  height: 0;</span><br><span class="line">  border-width: 20px;</span><br><span class="line">  border-style: solid;</span><br><span class="line">  border-color: transparent transparent red transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>一个满屏 品 字布局 如何设计?</strong></p>
<ul>
<li>简单的方式：<ul>
<li>上面的div宽100%，</li>
<li>下面的两个div分别宽50%，</li>
<li>然后用float或者inline使其不换行即可</li>
</ul>
</li>
</ul>
<p><strong>经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧 ？</strong></p>
<ul>
<li><p>png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8.</p>
</li>
<li><p>浏览器默认的margin和padding不同。解决方案是加一个全局的*{margin:0;padding:0;}来统一</p>
</li>
<li><p>IE下,可以使用获取常规属性的方法来获取自定义属性,也可以使用getAttribute()获取自定义属性;</p>
</li>
<li><p>Firefox下,只能使用getAttribute()获取自定义属性。</p>
<ul>
<li>解决方法:统一通过getAttribute()获取自定义属性</li>
</ul>
</li>
<li><p>IE下,even对象有x,y属性,但是没有pageX,pageY属性</p>
</li>
<li><p>Firefox下,event对象有pageX,pageY属性,但是没有x,y属性</p>
</li>
</ul>
<p><strong>li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？</strong></p>
<ul>
<li>行框的排列会受到中间空白（回车\空格）等的影响，因为空格也属于字符,这些空白也会被应用样式，占据空间，所以会有间隔，把字符大小设为0，就没有空格了</li>
</ul>
<p><strong>为什么要初始化CSS样式</strong></p>
<ul>
<li>因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异</li>
</ul>
<p><strong>对BFC规范(块级格式化上下文：block formatting context)的理解？</strong></p>
<ul>
<li>一个页面是由很多个 Box 组成的,元素的类型和 display 属性,决定了这个 Box 的类型</li>
<li>不同类型的 Box,会参与不同的 Formatting Context（决定如何渲染文档的容器）,因此Box内的元素会以不同的方式渲染,也就是说BFC内部的元素和外部的元素不会互相影响</li>
</ul>
<p><strong>css定义的权重</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 以下是权重的规则：标签的权重为1，class的权重为10，id的权重为100，以下/// 例子是演示各种定义的权重值：</span><br><span class="line"></span><br><span class="line">/*权重为1*/</span><br><span class="line">div&#123;</span><br><span class="line">&#125;</span><br><span class="line">/*权重为10*/</span><br><span class="line">.class1&#123;</span><br><span class="line">&#125;</span><br><span class="line">/*权重为100*/</span><br><span class="line">#id1&#123;</span><br><span class="line">&#125;</span><br><span class="line">/*权重为100+1=101*/</span><br><span class="line">#id1 div&#123;</span><br><span class="line">&#125;</span><br><span class="line">/*权重为10+1=11*/</span><br><span class="line">.class1 div&#123;</span><br><span class="line">&#125;</span><br><span class="line">/*权重为10+10+1=21*/</span><br><span class="line">.class1 .class2 div&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 如果权重相同，则最后定义的样式会起作用，但是应该避免这种情况出现</span><br></pre></td></tr></table></figure>

<p><strong>display:inline-block 什么时候会显示间隙？(携程)</strong></p>
<ul>
<li>移除空格、使用margin负值、使用font-size:0、letter-spacing、word-spacing</li>
</ul>
<p><strong>谈谈浮动和清除浮动</strong></p>
<ul>
<li>浮动的框可以向左或向右移动，直到他的外边缘碰到包含框或另一个浮动框的边框为止。由于浮动框不在文档的普通流中，所以文档的普通流的块框表现得就像浮动框不存在一样。浮动的块框会漂浮在文档普通流的块框上</li>
</ul>
<p><strong>介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？</strong></p>
<ul>
<li>盒子模型构成：内容(content)、内填充(padding)、 边框(border)、外边距(margin)</li>
<li>IE8及其以下版本浏览器，未声明 DOCTYPE，内容宽高会包含内填充和边框，称为怪异盒模型(IE盒模型)</li>
<li>标准(W3C)盒模型：元素宽度 = width + padding + border + margin</li>
<li>怪异(IE)盒模型：元素宽度 = width + margin</li>
<li>标准浏览器通过设置 css3 的 box-sizing: border-box 属性，触发“怪异模式”解析计算宽高</li>
</ul>
<p><strong>box-sizing 常用的属性有哪些？分别有什么作用？</strong></p>
<ul>
<li>box-sizing: content-box;  // 默认的标准(W3C)盒模型元素效果</li>
<li>box-sizing: border-box;   // 触发怪异(IE)盒模型元素的效果</li>
<li>box-sizing: inherit;      //  继承父元素 box-sizing 属性的值</li>
</ul>
<p><strong>CSS选择器有哪些？</strong></p>
<ul>
<li>id选择器        #id</li>
<li>类选择器        .class</li>
<li>标签选择器      div, h1, p</li>
<li>相邻选择器      h1 + p</li>
<li>子选择器        ul &gt; li</li>
<li>后代选择器      li a</li>
<li>通配符选择器    *</li>
<li>属性选择器      a[rel=’external’]</li>
<li>伪类选择器      a:hover, li:nth-child</li>
</ul>
<p><strong>CSS哪些属性可以继承？哪些属性不可以继承？</strong></p>
<ul>
<li>可以继承的样式：font-size、font-family、color、list-style、cursor</li>
<li>不可继承的样式：width、height、border、padding、margin、background</li>
</ul>
<p><strong>CSS如何计算选择器优先？</strong></p>
<ul>
<li>相同权重，定义最近者为准：行内样式 &gt; 内部样式 &gt; 外部样式</li>
<li>含外部载入样式时，后载入样式覆盖其前面的载入的样式和内部样式</li>
<li>选择器优先级: 行内样式[1000] &gt; id[100] &gt; class[10] &gt; Tag[1]</li>
<li>在同一组属性设置中，!important 优先级最高，高于行内样式</li>
</ul>
<p><strong>CSS3新增伪类有哪些？</strong></p>
<ul>
<li><p>:root           选择文档的根元素，等同于 html 元素</p>
</li>
<li><p>:empty          选择没有子元素的元素</p>
</li>
<li><p>:target         选取当前活动的目标元素</p>
</li>
<li><p>:not(selector)  选择除 selector 元素意外的元素</p>
</li>
<li><p>:enabled        选择可用的表单元素</p>
</li>
<li><p>:disabled       选择禁用的表单元素</p>
</li>
<li><p>:checked        选择被选中的表单元素</p>
</li>
<li><p>:after          在元素内部最前添加内容</p>
</li>
<li><p>:before         在元素内部最后添加内容</p>
</li>
<li><p>:nth-child(n)      匹配父元素下指定子元素，在所有子元素中排序第n</p>
</li>
<li><p>:nth-last-child(n) 匹配父元素下指定子元素，在所有子元素中排序第n，从后向前数</p>
</li>
<li><p>:nth-child(odd)</p>
</li>
<li><p>:nth-child(even)</p>
</li>
<li><p>:nth-child(3n+1)</p>
</li>
<li><p>:first-child</p>
</li>
<li><p>:last-child</p>
</li>
<li><p>:only-child</p>
</li>
<li><p>:nth-of-type(n)      匹配父元素下指定子元素，在同类子元素中排序第n</p>
</li>
<li><p>:nth-last-of-type(n) 匹配父元素下指定子元素，在同类子元素中排序第n，从后向前数</p>
</li>
<li><p>:nth-of-type(odd)</p>
</li>
<li><p>:nth-of-type(even)</p>
</li>
<li><p>:nth-of-type(3n+1)</p>
</li>
<li><p>:first-of-type</p>
</li>
<li><p>:last-of-type</p>
</li>
<li><p>:only-of-type</p>
</li>
<li><p>::selection     选择被用户选取的元素部分</p>
</li>
<li><p>:first-line     选择元素中的第一行</p>
</li>
<li><p>:first-letter   选择元素中的第一个字符</p>
</li>
</ul>
<p><strong>请列举几种隐藏元素的方法</strong></p>
<ul>
<li>visibility: hidden;   这个属性只是简单的隐藏某个元素，但是元素占用的空间任然存在</li>
<li>opacity: 0;           CSS3属性，设置0可以使一个元素完全透明</li>
<li>position: absolute;   设置一个很大的 left 负值定位，使元素定位在可见区域之外</li>
<li>display: none;        元素会变得不可见，并且不会再占用文档的空间。</li>
<li>transform: scale(0);  将一个元素设置为缩放无限小，元素将不可见，元素原来所在的位置将被保留</li>
<li><code>&lt;div hidden=&quot;hidden&quot;&gt;</code> HTML5属性,效果和display:none;相同，但这个属性用于记录一个元素的状态</li>
<li>height: 0;            将元素高度设为 0 ，并消除边框</li>
<li>filter: blur(0);      CSS3属性，将一个元素的模糊度设置为0，从而使这个元素“消失”在页面中</li>
</ul>
<p><strong>rgba() 和 opacity 的透明效果有什么不同？</strong></p>
<ul>
<li>opacity 作用于元素以及元素内的所有内容（包括文字）的透明度</li>
<li>rgba() 只作用于元素自身的颜色或其背景色，子元素不会继承透明效果</li>
</ul>
<p><strong>css 属性 content 有什么作用？</strong></p>
<ul>
<li>content 属性专门应用在 before/after 伪元素上，用于插入额外内容或样式</li>
</ul>
<p><strong>CSS3有哪些新特性？</strong></p>
<ul>
<li>新增选择器     p:nth-child(n){color: rgba(255, 0, 0, 0.75)}</li>
<li>弹性盒模型     display: flex;</li>
<li>多列布局       column-count: 5;</li>
<li>媒体查询       @media (max-width: 480px) {.box: {column-count: 1;}}</li>
<li>个性化字体     @font-face{font-family: BorderWeb; src:url(BORDERW0.eot);}</li>
<li>颜色透明度     color: rgba(255, 0, 0, 0.75);</li>
<li>圆角           border-radius: 5px;</li>
<li>渐变           background:linear-gradient(red, green, blue);</li>
<li>阴影           box-shadow:3px 3px 3px rgba(0, 64, 128, 0.3);</li>
<li>倒影           box-reflect: below 2px;</li>
<li>文字装饰       text-stroke-color: red;</li>
<li>文字溢出       text-overflow:ellipsis;</li>
<li>背景效果       background-size: 100px 100px;</li>
<li>边框效果       border-image:url(bt_blue.png) 0 10;</li>
<li>转换<ul>
<li>旋转          transform: rotate(20deg);</li>
<li>倾斜          transform: skew(150deg, -10deg);</li>
<li>位移          transform: translate(20px, 20px);</li>
<li>缩放          transform: scale(.5);</li>
</ul>
</li>
<li>平滑过渡       transition: all .3s ease-in .1s;</li>
<li>动画           @keyframes anim-1 {50% {border-radius: 50%;}} animation: anim-1 1s;</li>
</ul>
<p><strong>请解释一下 CSS3 的 Flexbox（弹性盒布局模型）以及适用场景？</strong></p>
<ul>
<li>Flexbox 用于不同尺寸屏幕中创建可自动扩展和收缩布局</li>
</ul>
<p><strong>经常遇到的浏览器的JS兼容性有哪些？解决方法是什么？</strong></p>
<ul>
<li>当前样式：getComputedStyle(el, null) VS el.currentStyle</li>
<li>事件对象：e VS window.event</li>
<li>鼠标坐标：e.pageX, e.pageY VS window.event.x, window.event.y</li>
<li>按键码：e.which VS event.keyCode</li>
<li>文本节点：el.textContent VS el.innerText</li>
</ul>
<p><strong>li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？</strong></p>
<ul>
<li>li排列受到中间空白(回车/空格)等的影响，因为空白也属于字符，会被应用样式占据空间，产生间隔</li>
<li>解决办法：在ul设置设置font-size=0,在li上设置需要的文字大小</li>
</ul>
<p><strong>什么是外边距重叠？ 重叠的结果是什么？</strong></p>
<ul>
<li><p>外边距重叠就是 margin-collapse</p>
</li>
<li><p>相邻的两个盒子（可能是兄弟关系也可能是祖先关系）的外边距可以结合成一个单独的外边距。<br>这种合并外边距的方式被称为折叠，结合而成的外边距称为折叠外边距</p>
</li>
<li><p>折叠结果遵循下列计算规则：</p>
<ul>
<li>两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值</li>
<li>两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值</li>
<li>两个外边距一正一负时，折叠结果是两者的相加的和</li>
</ul>
</li>
</ul>
<p><strong>请写出多种等高布局</strong></p>
<ul>
<li>在列的父元素上使用这个背景图进行Y轴的铺放，从而实现一种等高列的假像</li>
<li>模仿表格布局等高列效果：兼容性不好，在ie6-7无法正常运行</li>
<li>css3 flexbox 布局： .container{display: flex; align-items: stretch;}</li>
</ul>
<p><strong>css垂直居中的方法有哪些？</strong></p>
<ul>
<li>如果是单行文本, line-height 设置成和 height 值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.vertical &#123;</span><br><span class="line">      height: 100px;</span><br><span class="line">      line-height: 100px;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>已知高度的块级子元素，采用绝对定位和负边距</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  position: relative;</span><br><span class="line">&#125;</span><br><span class="line">.vertical &#123;</span><br><span class="line">  height: 300px;  /*子元素高度*/</span><br><span class="line">  position: absolute;</span><br><span class="line">  top:50%;  /*父元素高度50%*/</span><br><span class="line">  margin-top: -150px; /*自身高度一半*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>未知高度的块级父子元素居中，模拟表格布局</li>
<li>缺点：IE67不兼容，父级 overflow：hidden 失效</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">      display: table;</span><br><span class="line">    &#125;</span><br><span class="line">    .content &#123;</span><br><span class="line">      display: table-cell;</span><br><span class="line">      vertical-align: middle;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>新增 inline-block 兄弟元素，设置 vertical-align<ul>
<li>缺点：需要增加额外标签，IE67不兼容</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">.container &#123;</span><br><span class="line">  height: 100%;/*定义父级高度，作为参考*/</span><br><span class="line">&#125;</span><br><span class="line">.extra .vertical&#123;</span><br><span class="line">  display: inline-block;  /*行内块显示*/</span><br><span class="line">  vertical-align: middle; /*垂直居中*/</span><br><span class="line">&#125;</span><br><span class="line">.extra &#123;</span><br><span class="line">  height: 100%; /*设置新增元素高度为100%*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>绝对定位配合 CSS3 位移</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.vertical &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  top:50%;  /*父元素高度50%*/</span><br><span class="line">  transform:translateY(-50%, -50%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>CSS3弹性盒模型</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  display:flex;</span><br><span class="line">  justify-content: center; /*子元素水平居中*/</span><br><span class="line">  align-items: center; /*子元素垂直居中*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>圣杯布局的实现原理？</strong></p>
<ul>
<li>要求：三列布局；中间主体内容前置，且宽度自适应；两边内容定宽<ul>
<li>好处：重要的内容放在文档流前面可以优先渲染</li>
<li>原理：利用相对定位、浮动、负边距布局，而不添加额外标签</li>
</ul>
</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">padding-left</span>: <span class="number">150px</span>;</span><br><span class="line">    <span class="attribute">padding-right</span>: <span class="number">190px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.main</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">190px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">left</span>: -<span class="number">150px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">190px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">190px</span>;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">right</span>: -<span class="number">190px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>什么是双飞翼布局？实现原理？</strong></p>
<ul>
<li>双飞翼布局：对圣杯布局（使用相对定位，对以后布局有局限性）的改进，消除相对定位布局</li>
<li>原理：主体元素上设置左右边距，预留两翼位置。左右两栏使用浮动和负边距归位，消除相对定位。</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="comment">/*padding-left:150px;*/</span></span><br><span class="line">    <span class="comment">/*padding-right:190px;*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.main-wrap</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.main</span> &#123;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">150px</span>;</span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="number">190px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">150px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line">    <span class="comment">/*position: relative;*/</span></span><br><span class="line">    <span class="comment">/*left:-150px;*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">190px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">190px</span>;</span><br><span class="line">    <span class="comment">/*position:relative;*/</span></span><br><span class="line">    <span class="comment">/*right:-190px;*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在CSS样式中常使用 px、em 在表现上有什么区别？</strong></p>
<ul>
<li>px 相对于显示器屏幕分辨率，无法用浏览器字体放大功能</li>
<li>em 值并不是固定的，会继承父级的字体大小： em = 像素值 / 父级font-size</li>
</ul>
<p><strong>为什么要初始化CSS样式？</strong></p>
<ul>
<li>不同浏览器对有些标签样式的默认值解析不同</li>
<li>不初始化CSS会造成各现浏览器之间的页面显示差异</li>
<li>可以使用 reset.css 或 Normalize.css 做 CSS 初始化</li>
</ul>
<p><strong>解释下什么是浮动和它的工作原理？</strong></p>
<ul>
<li>非IE浏览器下，容器不设高度且子元素浮动时，容器高度不能被内容撑开。<br>此时，内容会溢出到容器外面而影响布局。这种现象被称为浮动（溢出）。</li>
<li>工作原理：<ul>
<li>浮动元素脱离文档流，不占据空间（引起“高度塌陷”现象）</li>
<li>浮动元素碰到包含它的边框或者其他浮动元素的边框停留</li>
</ul>
</li>
</ul>
<p><strong>浮动元素引起的问题？</strong></p>
<ul>
<li>父元素的高度无法被撑开，影响与父元素同级的元素</li>
<li>与浮动元素同级的非浮动元素会跟随其后</li>
</ul>
<p><strong>列举几种清除浮动的方式？</strong></p>
<ul>
<li>添加额外标签，例如 <code>&lt;div style=&quot;clear:both&quot;&gt;&lt;/div&gt;</code></li>
<li>使用 br 标签和其自身的 clear 属性，例如 <code>&lt;br clear=&quot;all&quot; /&gt;</code></li>
<li>父元素设置 overflow：hidden; 在IE6中还需要触发 hasLayout，例如zoom：1;</li>
<li>父元素也设置浮动</li>
<li>使用 :after 伪元素。由于IE6-7不支持 :after，使用 zoom:1 触发 hasLayout</li>
</ul>
<p><strong>清除浮动最佳实践（after伪元素闭合浮动）：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.clearfix:after&#123;</span><br><span class="line">    content: &quot;\200B&quot;;</span><br><span class="line">    display: table; </span><br><span class="line">    height: 0;</span><br><span class="line">    clear: both;</span><br><span class="line">  &#125;</span><br><span class="line">  .clearfix&#123;</span><br><span class="line">    *zoom: 1;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


<p>  <strong>什么是 FOUC(Flash of Unstyled Content)？ 如何来避免 FOUC？</strong></p>
<ul>
<li>当使用 @import 导入 CSS 时，会导致某些页面在 IE 出现奇怪的现象：<br>没有样式的页面内容显示瞬间闪烁，这种现象称为“文档样式短暂失效”，简称为FOUC<ul>
<li>产生原因：当样式表晚于结构性html加载时，加载到此样式表时，页面将停止之前的渲染。</li>
<li>等待此样式表被下载和解析后，再重新渲染页面，期间导致短暂的花屏现象。</li>
<li>解决方法：使用 link 标签将样式表放在文档 head</li>
</ul>
</li>
</ul>
<p><strong>介绍使用过的 CSS 预处理器？</strong></p>
<ul>
<li>CSS 预处理器基本思想：为 CSS 增加了一些编程的特性（变量、逻辑判断、函数等）</li>
<li>开发者使用这种语言进行进行 Web 页面样式设计，再编译成正常的 CSS 文件使用</li>
<li>使用 CSS 预处理器，可以使 CSS 更加简洁、适应性更强、可读性更佳，无需考虑兼容性</li>
<li>最常用的 CSS 预处理器语言包括：Sass（SCSS）和 LESS</li>
</ul>
<p><strong>CSS优化、提高性能的方法有哪些？</strong></p>
<ul>
<li>多个css合并，尽量减少HTTP请求</li>
<li>将css文件放在页面最上面</li>
<li>移除空的css规则</li>
<li>避免使用CSS表达式</li>
<li>选择器优化嵌套，尽量避免层级过深</li>
<li>充分利用css继承属性，减少代码量</li>
<li>抽象提取公共样式，减少代码量</li>
<li>属性值为0时，不加单位</li>
<li>属性值为小于1的小数时，省略小数点前面的0</li>
<li>css雪碧图</li>
</ul>
<p><strong>浏览器是怎样解析CSS选择器的？</strong></p>
<ul>
<li>浏览器解析 CSS 选择器的方式是从右到左</li>
</ul>
<p><strong>在网页中的应该使用奇数还是偶数的字体？</strong></p>
<ul>
<li>在网页中的应该使用“偶数”字体：<ul>
<li>偶数字号相对更容易和 web 设计的其他部分构成比例关系</li>
<li>使用奇数号字体时文本段落无法对齐</li>
<li>宋体的中文网页排布中使用最多的就是 12 和 14</li>
</ul>
</li>
</ul>
<p><strong>margin和padding分别适合什么场景使用？</strong></p>
<ul>
<li>需要在border外侧添加空白，且空白处不需要背景（色）时，使用 margin</li>
<li>需要在border内测添加空白，且空白处需要背景（色）时，使用 padding</li>
</ul>
<p><strong>抽离样式模块怎么写，说出思路？</strong></p>
<ul>
<li>CSS可以拆分成2部分：公共CSS 和 业务CSS：<ul>
<li>网站的配色，字体，交互提取出为公共CSS。这部分CSS命名不应涉及具体的业务</li>
<li>对于业务CSS，需要有统一的命名，使用公用的前缀。可以参考面向对象的CSS</li>
</ul>
</li>
</ul>
<p><strong>元素竖向的百分比设定是相对于容器的高度吗？</strong></p>
<ul>
<li>元素竖向的百分比设定是相对于容器的宽度，而不是高度</li>
</ul>
<p><strong>全屏滚动的原理是什么？ 用到了CSS的那些属性？</strong></p>
<ul>
<li>原理类似图片轮播原理，超出隐藏部分，滚动时显示</li>
<li>可能用到的CSS属性：overflow:hidden; transform:translate(100%, 100%); display:none;</li>
</ul>
<p><strong>什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？</strong></p>
<ul>
<li>响应式设计就是网站能够兼容多个终端，而不是为每个终端做一个特定的版本</li>
<li>基本原理是利用CSS3媒体查询，为不同尺寸的设备适配不同样式</li>
<li>对于低版本的IE，可采用JS获取屏幕宽度，然后通过resize方法来实现兼容：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">window</span>).resize(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  screenRespond();</span><br><span class="line">&#125;);</span><br><span class="line">screenRespond();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">screenRespond</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> screenWidth = $(<span class="built_in">window</span>).width();</span><br><span class="line"><span class="keyword">if</span>(screenWidth &lt;= <span class="number">1800</span>)&#123;</span><br><span class="line">  $(<span class="string">"body"</span>).attr(<span class="string">"class"</span>, <span class="string">"w1800"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(screenWidth &lt;= <span class="number">1400</span>)&#123;</span><br><span class="line">  $(<span class="string">"body"</span>).attr(<span class="string">"class"</span>, <span class="string">"w1400"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(screenWidth &gt; <span class="number">1800</span>)&#123;</span><br><span class="line">  $(<span class="string">"body"</span>).attr(<span class="string">"class"</span>, <span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>什么是视差滚动效果，如何给每页做不同的动画？</strong></p>
<ul>
<li>视差滚动是指多层背景以不同的速度移动，形成立体的运动效果，具有非常出色的视觉体验</li>
<li>一般把网页解剖为：背景层、内容层和悬浮层。当滚动鼠标滚轮时，各图层以不同速度移动，形成视差的</li>
</ul>
<ul>
<li>实现原理<ul>
<li>以 “页面滚动条” 作为 “视差动画进度条”</li>
<li>以 “滚轮刻度” 当作 “动画帧度” 去播放动画的</li>
<li>监听 mousewheel 事件，事件被触发即播放动画，实现“翻页”效果</li>
</ul>
</li>
</ul>
<p><strong>a标签上四个伪类的执行顺序是怎么样的？</strong></p>
<figure class="highlight plain"><figcaption><span>> visited > hover > active```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- L-V-H-A love hate 用喜欢和讨厌两个词来方便记忆</span><br><span class="line"></span><br><span class="line">**伪元素和伪类的区别和作用？**</span><br><span class="line"></span><br><span class="line">- 伪元素 -- 在内容元素的前后插入额外的元素或样式，但是这些元素实际上并不在文档中生成。</span><br><span class="line">- 它们只在外部显示可见，但不会在文档的源代码中找到它们，因此，称为“伪”元素。例如：</span><br></pre></td></tr></table></figure>

<p>p::before {content:”第一章：”;}<br>p::after {content:”Hot!”;}<br>p::first-line {background:red;}<br>p::first-letter {font-size:30px;}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 伪类 -- 将特殊的效果添加到特定选择器上。它是已有元素上添加类别的，不会产生新的元素。例如：</span><br></pre></td></tr></table></figure>

<p>a:hover {color: #FF00FF}<br>p:first-child {color: red}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**::before 和 :after 中双冒号和单冒号有什么区别？**</span><br><span class="line"></span><br><span class="line">* 在 CSS 中伪类一直用 : 表示，如 :hover, :active 等</span><br><span class="line">* 伪元素在CSS1中已存在，当时语法是用 : 表示，如 :before 和 :after</span><br><span class="line">* 后来在CSS3中修订，伪元素用 :: 表示，如 ::before 和 ::after，以此区分伪元素和伪类</span><br><span class="line">* 由于低版本IE对双冒号不兼容，开发者为了兼容性各浏览器，继续使使用 :after 这种老语法表示伪元素</span><br><span class="line">* 综上所述：::before 是 CSS3 中写伪元素的新语法； :after 是 CSS1 中存在的、兼容IE的老语法</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**如何修改Chrome记住密码后自动填充表单的黄色背景？**</span><br><span class="line"></span><br><span class="line">- 产生原因：由于Chrome默认会给自动填充的input表单加上 input:-webkit-autofill 私有属性造成的</span><br><span class="line">- 解决方案1：在form标签上直接关闭了表单的自动填充：autocomplete=&quot;off&quot;</span><br><span class="line">- 解决方案2：input:-webkit-autofill &#123; background-color: transparent; &#125;</span><br><span class="line"></span><br><span class="line">**input [type=search] 搜索框右侧小图标如何美化？**</span><br><span class="line"></span><br><span class="line">```css</span><br><span class="line">input[type=&quot;search&quot;]::-webkit-search-cancel-button&#123;</span><br><span class="line">  -webkit-appearance: none;</span><br><span class="line">  height: 15px;</span><br><span class="line">  width: 15px;</span><br><span class="line">  border-radius: 8px;</span><br><span class="line">  background:url(&quot;images/searchicon.png&quot;) no-repeat 0 0;</span><br><span class="line">  background-size: 15px 15px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>网站图片文件，如何点击下载？而非点击预览？</strong></p>
<p><code>&lt;a href=&quot;logo.jpg&quot; download&gt;下载&lt;/a&gt;</code><br><code>&lt;a href=&quot;logo.jpg&quot; download=&quot;网站LOGO&quot; &gt;下载&lt;/a&gt;</code></p>
<p><strong>iOS safari 如何阻止“橡皮筋效果”？</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> stopScrolling = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">        event.preventDefault();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">document</span>.addEventListener(<span class="string">'touchstart'</span>, stopScrolling, <span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">document</span>.addEventListener(<span class="string">'touchmove'</span>, stopScrolling, <span class="literal">false</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>你对 line-height 是如何理解的？</strong></p>
<ul>
<li>line-height 指一行字的高度，包含了字间距，实际上是下一行基线到上一行基线距离</li>
<li>如果一个标签没有定义 height 属性，那么其最终表现的高度是由 line-height 决定的</li>
<li>一个容器没有设置高度，那么撑开容器高度的是 line-height 而不是容器内的文字内容</li>
<li>把 line-height 值设置为 height 一样大小的值可以实现单行文字的垂直居中</li>
<li>line-height 和 height 都能撑开一个高度，height 会触发 haslayout，而 line-height 不会</li>
</ul>
<p><strong>line-height 三种赋值方式有何区别？（带单位、纯数字、百分比）</strong></p>
<ul>
<li>带单位：px 是固定值，而 em 会参考父元素 font-size 值计算自身的行高</li>
<li>纯数字：会把比例传递给后代。例如，父级行高为 1.5，子元素字体为 18px，则子元素行高为 1.5 * 18 = 27px</li>
<li>百分比：将计算后的值传递给后代</li>
</ul>
<p><strong>设置元素浮动后，该元素的 display 值会如何变化？</strong></p>
<ul>
<li>设置元素浮动后，该元素的 display 值自动变成 block</li>
</ul>
<p><strong>怎么让Chrome支持小于12px 的文字？</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.shrink</span>&#123;</span><br><span class="line">  <span class="attribute">-webkit-transform</span>:<span class="built_in">scale</span>(<span class="number">0.8</span>);</span><br><span class="line">  <span class="attribute">-o-transform</span>:<span class="built_in">scale</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="attribute">display</span>:inline-block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>让页面里的字体变清晰，变细用CSS怎么做？（IOS手机浏览器字体齿轮设置）</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">-webkit-font-smoothing</span>: <span class="selector-tag">antialiased</span>;</span><br></pre></td></tr></table></figure>

<p><strong>font-style 属性 oblique 是什么意思？</strong></p>
<ul>
<li>font-style: oblique; 使没有 italic 属性的文字实现倾斜</li>
</ul>
<p><strong>如果需要手动写动画，你认为最小时间间隔是多久？</strong></p>
<ul>
<li>16.7ms 多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔: 1s / 60 * 1000 ＝ 16.7ms</li>
</ul>
<p><strong>display:inline-block 什么时候会显示间隙？</strong></p>
<ul>
<li>相邻的 inline-block 元素之间有换行或空格分隔的情况下会产生间距</li>
<li>非 inline-block 水平元素设置为 inline-block 也会有水平间距</li>
<li>可以借助 vertical-align:top; 消除垂直间隙</li>
<li>可以在父级加 font-size：0; 在子元素里设置需要的字体大小，消除垂直间隙</li>
<li>把 li 标签写到同一行可以消除垂直间隙，但代码可读性差</li>
</ul>
<p><strong>overflow: scroll 时不能平滑滚动的问题怎么处理？</strong></p>
<ul>
<li>监听滚轮事件，然后滚动到一定距离时用 jquery 的 animate 实现平滑效果。</li>
</ul>
<p><strong>一个高度自适应的div，里面有两个div，一个高度100px，希望另一个填满剩下的高度</strong></p>
<ul>
<li>方案1：<br> <code>.sub { height: calc(100%-100px); }</code></li>
<li>方案2：<br> <code>.container { position:relative; }</code><br> <code>.sub { position: absolute; top: 100px; bottom: 0; }</code></li>
<li>方案3：<br> <code>.container { display:flex; flex-direction:column; }</code><br> <code>.sub { flex:1; }</code></li>
</ul>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  
  
  

</article>
    
    <article id="post-cross-domain" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    

    
    <div class="article-meta">
      <a href="/2020/04/16/cross-domain/" class="article-date">
  <time datetime="2020-04-15T17:36:59.910Z" itemprop="datePublished">2020-04-16</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h3 id="如何解决跨域问题"><a href="#如何解决跨域问题" class="headerlink" title="如何解决跨域问题"></a>如何解决跨域问题</h3><hr>
<p><strong>JSONP：</strong></p>
<ul>
<li>原理是：动态插入<code>script</code>标签，通过<code>script</code>标签引入一个<code>js</code>文件，这个<code>js</code>文件载入成功后会执行我们在<code>url</code>参数中指定的函数，并且会把我们需要的<code>json</code>数据作为参数传入</li>
<li>由于同源策略的限制，<code>XmlHttpRequest</code>只允许请求当前源（域名、协议、端口）的资源，为了实现跨域请求，可以通过<code>script</code>标签实现跨域请求，然后在服务端输出<code>JSON</code>数据并执行回调函数，从而解决了跨域的数据请求</li>
<li>优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持GET请求</li>
<li><code>JSONP</code>：<code>json+padding</code>（内填充），顾名思义，就是把<code>JSON</code>填充到一个盒子里</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createJs</span>(<span class="params">sUrl</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> oScript = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">    oScript.type = <span class="string">'text/javascript'</span>;</span><br><span class="line">    oScript.src = sUrl;</span><br><span class="line">    <span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>].appendChild(oScript);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createJs(<span class="string">'jsonp.js'</span>);</span><br><span class="line"></span><br><span class="line">box(&#123;</span><br><span class="line">   <span class="string">'name'</span>: <span class="string">'test'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">box</span>(<span class="params">json</span>)</span>&#123;</span><br><span class="line">    alert(json.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>CORS</strong></p>
<ul>
<li>服务器端对于<code>CORS</code>的支持，主要就是通过设置<code>Access-Control-Allow-Origin</code>来进行的。如果浏览器检测到相应的设置，就可以允许<code>Ajax</code>进行跨域的访问</li>
</ul>
<p><strong>通过修改document.domain来跨子域</strong></p>
<ul>
<li>将子域和主域的<code>document.domain</code>设为同一个主域.前提条件：这两个域名必须属于同一个基础域名!而且所用的协议，端口都要一致，否则无法利用<code>document.domain</code>进行跨域。主域相同的使用<code>document.domain</code></li>
</ul>
<p><strong>使用window.name来进行跨域</strong></p>
<ul>
<li><code>window</code>对象有个name属性，该属性有个特征：即在一个窗口(<code>window</code>)的生命周期内,窗口载入的所有的页面都是共享一个<code>window.name</code>的，每个页面对window.name都有读写的权限，<code>window.name</code>是持久存在一个窗口载入过的所有页面中的</li>
</ul>
<p><strong>使用HTML5中新引进的window.postMessage方法来跨域传送数据</strong></p>
<ul>
<li>还有<code>flash</code>、在服务器上设置代理页面等跨域方式。个人认为<code>window.name</code>的方法既不复杂，也能兼容到几乎所有浏览器，这真是极好的一种跨域方法</li>
</ul>
<p><strong>如何解决跨域问题?</strong></p>
<ul>
<li><p><code>jsonp</code>、 <code>iframe</code>、<code>window.name</code>、<code>window.postMessage</code>、服务器上设置代理页面</p>
</li>
<li><p>如何解决跨域问题?</p>
<ul>
<li><code>document.domain + iframe</code>：要求主域名相同 //只能跨子域</li>
<li><code>JSONP(JSON with Padding)``：</code>response: callback(data)`` //只支持 GET 请求</li>
<li>跨域资源共享<code>CORS(XHR2)``：</code>Access-Control-Allow` //兼容性 IE10+</li>
<li>跨文档消息传输(HTML5)：<code>postMessage + onmessage</code>  //兼容性 IE8+</li>
<li><code>WebSocket(HTML5)：new WebSocket(url) + onmessage</code> //兼容性 IE10+</li>
<li>服务器端设置代理请求：服务器端不受同源策略限制</li>
</ul>
</li>
</ul>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  
  
  

</article>
    
    <article id="post-cookie" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    

    
    <div class="article-meta">
      <a href="/2020/04/16/cookie/" class="article-date">
  <time datetime="2020-04-15T17:36:59.902Z" itemprop="datePublished">2020-04-16</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <p><strong>请你谈谈Cookie的弊端</strong></p>
<ul>
<li><p>cookie虽然在持久保存客户端数据提供了方便，分担了服务器存储的负担，但还是有很多局限性的</p>
</li>
<li><p>第一：每个特定的域名下最多生成20个cookie</p>
</li>
<li><p>1.IE6或更低版本最多20个cookie</p>
</li>
<li><p>2.IE7和之后的版本最后可以有50个cookie。</p>
</li>
<li><p>3.Firefox最多50个cookie</p>
</li>
<li><p>4.chrome和Safari没有做硬性限制</p>
</li>
</ul>
<p><strong>请你谈谈Cookie的弊端？</strong></p>
<ul>
<li>每个特定的域名下最多生成的 cookie 个数有限制</li>
<li>IE 和 Opera 会清理近期最少使用的 cookie，Firefox 会随机清理 cookie</li>
<li>cookie 的最大大约为 4096 字节，为了兼容性，一般设置不超过 4095 字节</li>
<li>如果 cookie 被人拦截了，就可以取得所有的 session 信息</li>
</ul>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  
  
  

</article>
    
    <article id="post-computer-basic-knowledge" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    

    
    <div class="article-meta">
      <a href="/2020/04/16/computer-basic-knowledge/" class="article-date">
  <time datetime="2020-04-15T17:36:59.899Z" itemprop="datePublished">2020-04-16</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <p><strong>线程与进程的区别</strong></p>
<ul>
<li>一个程序至少有一个进程，一个进程至少有一个线程</li>
<li>线程的划分尺度小于进程，使得多线程程序的并发性高</li>
<li>进程在执行过程中拥有独立的内存单元，而多个线程共享内存</li>
<li>线程不能够独立执行，必须应用程序提供多个线程执行控制</li>
</ul>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  
  
  

</article>
    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/3/">上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/5/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2020
        <i class="ri-heart-fill heart_icon"></i> 王金龙
      </li>
    </ul>
   
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></s>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="王金龙"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/旅行/">旅行</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="http://shenyu-vip.lofter.com">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="https://">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="https://">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/lazyload.min.js"></script>

<script>
  try {
    var typed = new Typed("#subtitle", {
      strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
      startDelay: 0,
      typeSpeed: 200,
      loop: true,
      backSpeed: 100,
      showCursor: true
    });
  } catch (err) {
  }

</script>





<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>
<script src="/dist/main.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>




<script src="/js/busuanzi-2.3.pure.min.js"></script>


<script type="text/javascript" src="https://js.users.51.la/20544303.js"></script>


<!-- 复制 -->

  <link rel="stylesheet" href="/css/clipboard.css">
  <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>




    
  </div>
</body>

</html>