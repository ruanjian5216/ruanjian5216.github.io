<!DOCTYPE html>


<html lang="zh-CN">


<head>
  <meta charset="utf-8" />
   
  <meta name="keywords" content="生活,旅行,思考,代码,博客" />
   
  <meta name="description" content="一座孤岛" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     王金龙
  </title>
  <meta name="generator" content="hexo-theme-yilia-plus">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  <link rel="stylesheet" href="/dist/main.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css">
  <link rel="stylesheet" href="/css/custom.css">
  
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
  
  

  

</head>

</html>

<body>
  <div id="app">
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/ruanjian5216"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover2.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">王金龙</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>

<div id="main">
  <section class="outer">
  <article class="articles">
    
    
    
    
    <article id="post-mobile-terminal" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    

    
    <div class="article-meta">
      <a href="/2020/04/16/mobile-terminal/" class="article-date">
  <time datetime="2020-04-15T17:37:00.091Z" itemprop="datePublished">2020-04-16</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <p><strong>移动端（Android、IOS）怎么做好用户体验?</strong></p>
<ul>
<li>清晰的视觉纵线</li>
<li>信息的分组、极致的减法</li>
<li>利用选择代替输入</li>
<li>标签及文字的排布方式</li>
<li>依靠明文确认密码</li>
<li>合理的键盘利用</li>
</ul>
<p><strong>前端页面有哪三层构成，分别是什么？作用是什么？</strong></p>
<ul>
<li>结构层：由 (X)HTML 标记语言负责，解决页面“内容是什么”的问题</li>
<li>表示层：由 CSS 负责，解决页面“如何显示内容”的问题</li>
<li>行为层：由 JS 脚本负责，解决页面上“内容应该如何对事件作出反应”的问题</li>
</ul>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  
  
  

</article>
    
    <article id="post-localStorage" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    

    
    <div class="article-meta">
      <a href="/2020/04/16/localStorage/" class="article-date">
  <time datetime="2020-04-15T17:37:00.084Z" itemprop="datePublished">2020-04-16</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <p><strong>浏览器本地存储</strong></p>
<ul>
<li>在较高版本的浏览器中，js提供了sessionStorage和globalStorage。在HTML5中提供了localStorage来取代globalStorage</li>
<li>html5中的Web Storage包括了两种存储方式：sessionStorage和localStorage</li>
<li>sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储</li>
<li>而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的</li>
</ul>
<p><strong>web storage和cookie的区别</strong></p>
<ul>
<li>Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小是受限的，并且每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可以跨域调用</li>
<li>除此之外，WebStorage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要前端开发者自己封装setCookie，getCookie</li>
<li>但是cookie也是不可以或缺的：cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生</li>
<li>浏览器的支持除了IE７及以下不支持外，其他标准浏览器都完全支持(ie及FF需在web服务器里运行)，值得一提的是IE总是办好事，例如IE7、IE6中的userData其实就是javascript本地存储的解决方案。通过简单的代码封装可以统一到所有的浏览器都支持web storage</li>
<li>localStorage和sessionStorage都具有相同的操作方法，例如setItem、getItem和removeItem等</li>
</ul>
<p><strong>cookie 和session 的区别：</strong></p>
<ul>
<li><p>1、cookie数据存放在客户的浏览器上，session数据放在服务器上。</p>
</li>
<li><p>2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗</p>
<ul>
<li>考虑到安全应当使用session。</li>
</ul>
</li>
<li><p>3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能</p>
<ul>
<li>考虑到减轻服务器性能方面，应当使用COOKIE。</li>
</ul>
</li>
<li><p>4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</p>
</li>
<li><p>5、所以个人建议：</p>
<ul>
<li><p>将登陆信息等重要信息存放为SESSION</p>
</li>
<li><p>其他信息如果需要保留，可以放在COOKIE中</p>
</li>
</ul>
</li>
</ul>
<p><strong>描述 cookies、sessionStorage 和 localStorage 的区别？</strong></p>
<ul>
<li><p>与服务器交互：</p>
<ul>
<li>cookie 是网站为了标示用户身份而储存在用户本地终端上的数据（通常经过加密）</li>
<li>cookie 始终会在同源 http 请求头中携带（即使不需要），在浏览器和服务器间来回传递</li>
<li>sessionStorage 和 localStorage 不会自动把数据发给服务器，仅在本地保存</li>
</ul>
<ul>
<li>存储大小：</li>
</ul>
<ul>
<li>cookie 数据根据不同浏览器限制，大小一般不能超过 4k</li>
<li>sessionStorage 和 localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大</li>
</ul>
</li>
<li><p>有期时间：</p>
<ul>
<li>localStorage    存储持久数据，浏览器关闭后数据不丢失除非主动删除数据</li>
<li>sessionStorage  数据在当前浏览器窗口关闭后自动删除</li>
<li>cookie           设置的cookie过期时间之前一直有效，与浏览器是否关闭无关</li>
</ul>
</li>
</ul>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  
  
  

</article>
    
    <article id="post-Json-XML" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    

    
    <div class="article-meta">
      <a href="/2020/04/16/Json-XML/" class="article-date">
  <time datetime="2020-04-15T17:37:00.079Z" itemprop="datePublished">2020-04-16</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <p><strong>XML和JSON的区别？</strong></p>
<ul>
<li><p>数据体积方面</p>
<ul>
<li>JSON相对于XML来讲，数据的体积小，传递的速度更快些。</li>
</ul>
</li>
<li><p>数据交互方面</p>
<ul>
<li>JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互</li>
</ul>
</li>
<li><p>数据描述方面</p>
<ul>
<li>JSON对数据的描述性比XML较差</li>
</ul>
</li>
<li><p>传输速度方面</p>
<ul>
<li>JSON的速度要远远快于XML</li>
</ul>
</li>
</ul>
<p><strong>JSON 的了解？</strong></p>
<ul>
<li><p>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式</p>
</li>
<li><p>它是基于JavaScript的一个子集。数据格式简单, 易于读写, 占用带宽小</p>
</li>
<li><p>JSON字符串转换为JSON对象:</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var obj =eval(&apos;(&apos;+ str +&apos;)&apos;);</span><br><span class="line">var obj = str.parseJSON();</span><br><span class="line">var obj = JSON.parse(str);</span><br></pre></td></tr></table></figure>

<ul>
<li>JSON对象转换为JSON字符串：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var last=obj.toJSONString();</span><br><span class="line">var last=JSON.stringify(obj);</span><br></pre></td></tr></table></figure>
      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  
  
  

</article>
    
    <article id="post-jQuery" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    

    
    <div class="article-meta">
      <a href="/2020/04/16/jQuery/" class="article-date">
  <time datetime="2020-04-15T17:37:00.062Z" itemprop="datePublished">2020-04-16</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <p><strong>你觉得jQuery或zepto源码有哪些写的好的地方</strong></p>
<ul>
<li>jquery源码封装在一个匿名函数的自执行环境中，有助于防止变量的全局污染，然后通过传入window对象参数，可以使window对象作为局部变量使用，好处是当jquery中访问window对象的时候，就不用将作用域链退回到顶层作用域了，从而可以更快的访问window对象。同样，传入undefined参数，可以缩短查找undefined时的作用域链</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(function( window, undefined ) &#123;</span><br><span class="line"></span><br><span class="line">        //用一个函数域包起来，就是所谓的沙箱</span><br><span class="line"></span><br><span class="line">        //在这里边var定义的变量，属于这个函数域内的局部变量，避免污染全局</span><br><span class="line"></span><br><span class="line">        //把当前沙箱需要的外部变量通过函数参数引入进来</span><br><span class="line"></span><br><span class="line">        //只要保证参数对内提供的接口的一致性，你还可以随意替换传进来的这个参数</span><br><span class="line"></span><br><span class="line">       window.jQuery = window.$ = jQuery;</span><br><span class="line"></span><br><span class="line">   &#125;)( window );</span><br></pre></td></tr></table></figure>

<ul>
<li>jquery将一些原型属性和方法封装在了jquery.prototype中，为了缩短名称，又赋值给了jquery.fn，这是很形象的写法</li>
<li>有一些数组或对象的方法经常能使用到，jQuery将其保存为局部变量以提高访问速度</li>
<li>jquery实现的链式调用可以节约代码，所返回的都是同一个对象，可以提高代码效率</li>
</ul>
<p><strong>jQuery 的实现原理？</strong></p>
<ul>
<li><p><code>(function(window, undefined) {})(window);</code></p>
</li>
<li><p>jQuery 利用 JS 函数作用域的特性，采用立即调用表达式包裹了自身，解决命名空间和变量污染问题</p>
</li>
<li><p><code>window.jQuery = window.$ = jQuery;</code></p>
</li>
<li><p>在闭包当中将 jQuery 和 $ 绑定到 window 上，从而将 jQuery 和 $ 暴露为全局变量</p>
</li>
</ul>
<p><strong>jQuery.fn 的 init 方法返回的 this 指的是什么对象？ 为什么要返回 this？</strong></p>
<ul>
<li>jQuery.fn 的 init 方法 返回的 this 就是 jQuery 对象</li>
<li>用户使用 jQuery() 或 $() 即可初始化 jQuery 对象，不需要动态的去调用 init 方法</li>
</ul>
<p><strong>jQuery.extend 与 jQuery.fn.extend 的区别？</strong></p>
<ul>
<li>$.fn.extend() 和 $.extend() 是 jQuery 为扩展插件提拱了两个方法</li>
<li>$.extend(object); // 为jQuery添加“静态方法”（工具方法）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$.extend(&#123;</span><br><span class="line">　　min: function(a, b) &#123; return a &lt; b ? a : b; &#125;,</span><br><span class="line">　　max: function(a, b) &#123; return a &gt; b ? a : b; &#125;</span><br><span class="line">&#125;);</span><br><span class="line">$.min(2,3); //  2</span><br><span class="line">$.max(4,5); //  5</span><br></pre></td></tr></table></figure>

<ul>
<li>$.extend([true,] targetObject, object1[, object2]); // 对targt对象进行扩展<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var settings = &#123;validate:false, limit:5&#125;;</span><br><span class="line">var options = &#123;validate:true, name:&quot;bar&quot;&#125;;</span><br><span class="line">$.extend(settings, options);  // 注意：不支持第一个参数传 false</span><br><span class="line">// settings == &#123;validate:true, limit:5, name:&quot;bar&quot;&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<ul>
<li>$.fn.extend(json); // 为jQuery添加“成员函数”（实例方法）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$.fn.extend(&#123;</span><br><span class="line">   alertValue: function() &#123;</span><br><span class="line">      $(this).click(function()&#123;</span><br><span class="line">        alert($(this).val());</span><br><span class="line">      &#125;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$(&quot;#email&quot;).alertValue();</span><br></pre></td></tr></table></figure>

<p><strong>jQuery 的属性拷贝(extend)的实现原理是什么，如何实现深拷贝？</strong></p>
<ul>
<li><p>浅拷贝（只复制一份原始对象的引用）<br><code>var newObject = $.extend({}, oldObject);</code></p>
</li>
<li><p>深拷贝（对原始对象属性所引用的对象进行进行递归拷贝）<br><code>var newObject = $.extend(true, {}, oldObject);</code></p>
</li>
</ul>
<p><strong>jQuery 的队列是如何实现的？队列可以用在哪些地方？</strong></p>
<ul>
<li>jQuery 核心中有一组队列控制方法，由 queue()/dequeue()/clearQueue() 三个方法组成。</li>
<li>主要应用于 animate()，ajax，其他要按时间顺序执行的事件中</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> func1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'事件1'</span>);&#125;</span><br><span class="line"><span class="keyword">var</span> func2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'事件2'</span>);&#125;</span><br><span class="line"><span class="keyword">var</span> func3 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'事件3'</span>);&#125;</span><br><span class="line"><span class="keyword">var</span> func4 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'事件4'</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入栈队列事件</span></span><br><span class="line">$(<span class="string">'#box'</span>).queue(<span class="string">"queue1"</span>, func1);  <span class="comment">// push func1 to queue1</span></span><br><span class="line">$(<span class="string">'#box'</span>).queue(<span class="string">"queue1"</span>, func2);  <span class="comment">// push func2 to queue1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 替换队列事件</span></span><br><span class="line">$(<span class="string">'#box'</span>).queue(<span class="string">"queue1"</span>, []);  <span class="comment">// delete queue1 with empty array</span></span><br><span class="line">$(<span class="string">'#box'</span>).queue(<span class="string">"queue1"</span>, [func3, func4]);  <span class="comment">// replace queue1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取队列事件（返回一个函数数组）</span></span><br><span class="line">$(<span class="string">'#box'</span>).queue(<span class="string">"queue1"</span>);  <span class="comment">// [func3(), func4()]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 出栈队列事件并执行</span></span><br><span class="line">$(<span class="string">'#box'</span>).dequeue(<span class="string">"queue1"</span>); <span class="comment">// return func3 and do func3</span></span><br><span class="line">$(<span class="string">'#box'</span>).dequeue(<span class="string">"queue1"</span>); <span class="comment">// return func4 and do func4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空整个队列</span></span><br><span class="line">$(<span class="string">'#box'</span>).clearQueue(<span class="string">"queue1"</span>); <span class="comment">// delete queue1 with clearQueue</span></span><br></pre></td></tr></table></figure>

<p><strong>jQuery 中的 bind(), live(), delegate(), on()的区别？</strong></p>
<ul>
<li>bind 直接绑定在目标元素上</li>
<li>live 通过冒泡传播事件，默认document上，支持动态数据</li>
<li>delegate 更精确的小范围使用事件代理，性能优于 live</li>
<li>on 是最新的1.9版本整合了之前的三种方式的新事件绑定机制</li>
</ul>
<p><strong>是否知道自定义事件？ jQuery 里的 fire 函数是什么意思，什么时候用？</strong></p>
<ul>
<li>事件即“发布/订阅”模式，自定义事件即“消息发布”，事件的监听即“订阅订阅”</li>
<li>JS 原生支持自定义事件，示例：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.createEvent(type); <span class="comment">// 创建事件</span></span><br><span class="line">event.initEvent(eventType, canBubble, prevent); <span class="comment">// 初始化事件</span></span><br><span class="line">target.addEventListener(<span class="string">'dataavailable'</span>, handler, <span class="literal">false</span>); <span class="comment">// 监听事件</span></span><br><span class="line">target.dispatchEvent(e);  <span class="comment">// 触发事件</span></span><br></pre></td></tr></table></figure>

<ul>
<li>jQuery 里的 fire 函数用于调用 jQuery 自定义事件列表中的事件</li>
</ul>
<p><strong>jQuery 通过哪个方法和 Sizzle 选择器结合的？</strong></p>
<ul>
<li>Sizzle 选择器采取 Right To Left 的匹配模式，先搜寻所有匹配标签，再判断它的父节点</li>
<li>jQuery 通过 $(selecter).find(selecter); 和 Sizzle 选择器结合</li>
</ul>
<p><strong>jQuery 中如何将数组转化为 JSON 字符串，然后再转化回来？</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过原生 JSON.stringify/JSON.parse 扩展 jQuery 实现</span></span><br><span class="line"> $.array2json = <span class="function"><span class="keyword">function</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify(array);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> $.json2array = <span class="function"><span class="keyword">function</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// $.parseJSON(array); // 3.0 开始，已过时</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">JSON</span>.parse(array);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 调用</span></span><br><span class="line"> <span class="keyword">var</span> json = $.array2json([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]);</span><br><span class="line"> <span class="keyword">var</span> array = $.json2array(json);</span><br></pre></td></tr></table></figure>

<p><strong>jQuery 一个对象可以同时绑定多个事件，这是如何实现的？</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#btn"</span>).on(<span class="string">"mouseover mouseout"</span>, func);</span><br><span class="line"></span><br><span class="line">$(<span class="string">"#btn"</span>).on(&#123;</span><br><span class="line">    mouseover: func1,</span><br><span class="line">    mouseout: func2,</span><br><span class="line">    click: func3</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>针对 jQuery 的优化方法？</strong></p>
<ul>
<li>缓存频繁操作DOM对象</li>
<li>尽量使用id选择器代替class选择器</li>
<li>总是从#id选择器来继承</li>
<li>尽量使用链式操作</li>
<li>使用时间委托 on 绑定事件</li>
<li>采用jQuery的内部函数data()来存储数据</li>
<li>使用最新版本的 jQuery</li>
</ul>
<p><strong>jQuery 的 slideUp 动画，当鼠标快速连续触发, 动画会滞后反复执行，该如何处理呢?</strong></p>
<ul>
<li>在触发元素上的事件设置为延迟处理：使用 JS 原生 setTimeout 方法</li>
<li>在触发元素的事件时预先停止所有的动画，再执行相应的动画事件：$(‘.tab’).stop().slideUp();</li>
</ul>
<p><strong>jQuery UI 如何自定义组件？</strong></p>
<ul>
<li>通过向 $.widget() 传递组件名称和一个原型对象来完成</li>
<li><code>$.widget(&quot;ns.widgetName&quot;, [baseWidget], widgetPrototype);</code></li>
</ul>
<p><strong>jQuery 与 jQuery UI、jQuery Mobile 区别？</strong></p>
<ul>
<li><p>jQuery 是 JS 库，兼容各种PC浏览器，主要用作更方便地处理 DOM、事件、动画、AJAX</p>
</li>
<li><p>jQuery UI 是建立在 jQuery 库上的一组用户界面交互、特效、小部件及主题</p>
</li>
<li><p>jQuery Mobile 以 jQuery 为基础，用于创建“移动Web应用”的框架</p>
</li>
</ul>
<p><strong>jQuery 和 Zepto 的区别？ 各自的使用场景？</strong></p>
<ul>
<li>jQuery 主要目标是PC的网页中，兼容全部主流浏览器。在移动设备方面，单独推出 jQuery Mobile</li>
<li>Zepto 从一开始就定位移动设备，相对更轻量级。它的 API 基本兼容 jQuery，但对PC浏览器兼容不理想</li>
</ul>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  
  
  

</article>
    
    <article id="post-JavaScript" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    

    
    <div class="article-meta">
      <a href="/2020/04/16/JavaScript/" class="article-date">
  <time datetime="2020-04-15T17:37:00.045Z" itemprop="datePublished">2020-04-16</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><hr>
<p><strong>JavaScript的组成</strong></p>
<ul>
<li>JavaScript 由以下三部分组成：<ul>
<li>ECMAScript（核心）：JavaScript 语言基础</li>
<li>DOM（文档对象模型）：规定了访问HTML和XML的接口</li>
<li>BOM（浏览器对象模型）：提供了浏览器窗口之间进行交互的对象和方法</li>
</ul>
</li>
</ul>
<p><strong>JS的基本数据类型和引用数据类型</strong></p>
<ul>
<li>基本数据类型：undefined、null、boolean、number、string、symbol</li>
<li>引用数据类型：object、array、function</li>
</ul>
<p><strong>检测浏览器版本版本有哪些方式？</strong></p>
<ul>
<li>根据 navigator.userAgent   //  UA.toLowerCase().indexOf(‘chrome’)</li>
<li>根据 window 对象的成员       // ‘ActiveXObject’ in window</li>
</ul>
<p><strong>介绍JS有哪些内置对象？</strong></p>
<ul>
<li>数据封装类对象：Object、Array、Boolean、Number、String</li>
<li>其他对象：Function、Arguments、Math、Date、RegExp、Error</li>
<li>ES6新增对象：Symbol、Map、Set、Promises、Proxy、Reflect</li>
</ul>
<p><strong>说几条写JavaScript的基本规范？</strong></p>
<ul>
<li>代码缩进，建议使用“四个空格”缩进</li>
<li>代码段使用花括号{}包裹</li>
<li>语句结束使用分号;</li>
<li>变量和函数在使用前进行声明</li>
<li>以大写字母开头命名构造函数，全大写命名常量</li>
<li>规范定义JSON对象，补全双引号</li>
<li>用{}和[]声明对象和数组</li>
</ul>
<p><strong>如何编写高性能的JavaScript？</strong></p>
<ul>
<li>遵循严格模式：”use strict”;</li>
<li>将js脚本放在页面底部，加快渲染页面</li>
<li>将js脚本将脚本成组打包，减少请求</li>
<li>使用非阻塞方式下载js脚本</li>
<li>尽量使用局部变量来保存全局变量</li>
<li>尽量减少使用闭包</li>
<li>使用 window 对象属性方法时，省略 window</li>
<li>尽量减少对象成员嵌套</li>
<li>缓存 DOM 节点的访问</li>
<li>通过避免使用 eval() 和 Function() 构造器</li>
<li>给 setTimeout() 和 setInterval() 传递函数而不是字符串作为参数</li>
<li>尽量使用直接量创建对象和数组</li>
<li>最小化重绘(repaint)和回流(reflow)</li>
</ul>
<p><strong>描述浏览器的渲染过程，DOM树和渲染树的区别？</strong></p>
<ul>
<li><p>浏览器的渲染过程：</p>
<ul>
<li>解析HTML构建 DOM(DOM树)，并行请求 css/image/js</li>
<li>CSS 文件下载完成，开始构建 CSSOM(CSS树)</li>
<li>CSSOM 构建结束后，和 DOM 一起生成 Render Tree(渲染树)</li>
<li>布局(Layout)：计算出每个节点在屏幕中的位置</li>
<li>显示(Painting)：通过显卡把页面画到屏幕上</li>
</ul>
</li>
<li><p>DOM树 和 渲染树 的区别：</p>
<ul>
<li>DOM树与HTML标签一一对应，包括head和隐藏元素</li>
<li>渲染树不包括head和隐藏元素，大段文本的每一个行都是独立节点，每一个节点都有对应的css属性</li>
</ul>
</li>
</ul>
<p><strong>重绘和回流（重排）的区别和关系？</strong></p>
<ul>
<li>重绘：当渲染树中的元素外观（如：颜色）发生改变，不影响布局时，产生重绘</li>
<li>回流：当渲染树中的元素的布局（如：尺寸、位置、隐藏/状态状态）发生改变时，产生重绘回流</li>
<li>注意：JS获取Layout属性值（如：offsetLeft、scrollTop、getComputedStyle等）也会引起回流。因为浏览器需要通过回流计算最新值</li>
<li>回流必将引起重绘，而重绘不一定会引起回流</li>
</ul>
<p><strong>如何最小化重绘(repaint)和回流(reflow)？</strong></p>
<ul>
<li>需要要对元素进行复杂的操作时，可以先隐藏(display:”none”)，操作完成后再显示</li>
<li>需要创建多个DOM节点时，使用DocumentFragment创建完后一次性的加入document</li>
<li>缓存Layout属性值，如：var left = elem.offsetLeft; 这样，多次使用 left 只产生一次回流</li>
<li>尽量避免用table布局（table元素一旦触发回流就会导致table里所有的其它元素回流）</li>
<li>避免使用css表达式(expression)，因为每次调用都会重新计算值（包括加载页面）</li>
<li>尽量使用 css 属性简写，如：用 border 代替 border-width, border-style, border-color</li>
<li>批量修改元素样式：elem.className 和 elem.style.cssText 代替 elem.style.xxx</li>
</ul>
<p><strong>script 的位置是否会影响首屏显示时间？</strong></p>
<ul>
<li>在解析 HTML 生成 DOM 过程中，js 文件的下载是并行的，不需要 DOM 处理到 script 节点。因此，script的位置不影响首屏显示的开始时间。</li>
<li>浏览器解析 HTML 是自上而下的线性过程，script作为 HTML 的一部分同样遵循这个原则</li>
<li>因此，script 会延迟 DomContentLoad，只显示其上部分首屏内容，从而影响首屏显示的完成时间</li>
</ul>
<p><strong>解释JavaScript中的作用域与变量声明提升？</strong></p>
<ul>
<li><p>JavaScript作用域：</p>
<ul>
<li>在Java、C等语言中，作用域为for语句、if语句或{}内的一块区域，称为作用域；</li>
<li>而在 JavaScript 中，作用域为function(){}内的区域，称为函数作用域。</li>
</ul>
</li>
<li><p>JavaScript变量声明提升：</p>
<ul>
<li>在JavaScript中，函数声明与变量声明经常被JavaScript引擎隐式地提升到当前作用域的顶部。</li>
<li>声明语句中的赋值部分并不会被提升，只有名称被提升</li>
<li>函数声明的优先级高于变量，如果变量名跟函数名相同且未赋值，则函数声明会覆盖变量声明</li>
<li>如果函数有多个同名参数，那么最后一个参数（即使没有定义）会覆盖前面的同名参数</li>
</ul>
</li>
</ul>
<p><strong>介绍JavaScript的原型，原型链？有什么特点？</strong></p>
<ul>
<li><p>原型：</p>
<ul>
<li>JavaScript的所有对象中都包含了一个 [<strong>proto</strong>] 内部属性，这个属性所对应的就是该对象的原型</li>
<li>JavaScript的函数对象，除了原型 [<strong>proto</strong>] 之外，还预置了 prototype 属性</li>
<li>当函数对象作为构造函数创建实例时，该 prototype 属性值将被作为实例对象的原型 [<strong>proto</strong>]。</li>
</ul>
</li>
<li><p>原型链：</p>
<ul>
<li>当一个对象调用的属性/方法自身不存在时，就会去自己 [<strong>proto</strong>] 关联的前辈 prototype 对象上去找</li>
<li>如果没找到，就会去该 prototype 原型 [<strong>proto</strong>] 关联的前辈 prototype 去找。依次类推，直到找到属性/方法或 undefined 为止。从而形成了所谓的“原型链”</li>
</ul>
</li>
</ul>
<ul>
<li>原型特点：<ul>
<li>JavaScript对象是通过引用来传递的，当修改原型时，与之相关的对象也会继承这一改变</li>
</ul>
</li>
</ul>
<p><strong>JavaScript有几种类型的值？，你能画一下他们的内存图吗</strong></p>
<ul>
<li>原始数据类型（Undefined，Null，Boolean，Number、String）– 栈</li>
<li>引用数据类型（对象、数组和函数）– 堆</li>
<li>两种类型的区别是：存储位置不同：</li>
<li>原始数据类型是直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据；</li>
<li>引用数据类型存储在堆(heap)中的对象，占据空间大、大小不固定，如果存储在栈中，将会影响程序运行的性能；</li>
<li>引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。</li>
<li>当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。</li>
</ul>
<p><strong>JavaScript如何实现一个类，怎么实例化这个类？</strong></p>
<ul>
<li>构造函数法（this + prototype） – 用 new 关键字 生成实例对象<ul>
<li>缺点：用到了 this 和 prototype，编写复杂，可读性差</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Mobile</span>(<span class="params">name, price</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.name = name;</span><br><span class="line">   <span class="keyword">this</span>.price = price;</span><br><span class="line"> &#125;</span><br><span class="line"> Mobile.prototype.sell = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name + <span class="string">"，售价 $"</span> + <span class="keyword">this</span>.price);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">var</span> iPhone7 = <span class="keyword">new</span> Mobile(<span class="string">"iPhone7"</span>, <span class="number">1000</span>);</span><br><span class="line"> iPhone7.sell();</span><br></pre></td></tr></table></figure>

<ul>
<li>Object.create 法 – 用 Object.create() 生成实例对象</li>
<li>缺点：不能实现私有属性和私有方法，实例对象之间也不能共享数据</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = &#123;</span><br><span class="line">    firstname: <span class="string">"Mark"</span>,</span><br><span class="line">    lastname: <span class="string">"Yun"</span>,</span><br><span class="line">    age: <span class="number">25</span>,</span><br><span class="line">    introduce: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="string">'I am '</span> + Person.firstname + <span class="string">' '</span> + Person.lastname);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="built_in">Object</span>.create(Person);</span><br><span class="line">person.introduce();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Object.create 要求 IE9+，低版本浏览器可以自行部署：</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">Object</span>.create) &#123;</span><br><span class="line">　   <span class="built_in">Object</span>.create = <span class="function"><span class="keyword">function</span> (<span class="params">o</span>) </span>&#123;</span><br><span class="line">　　　 <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">　　　 F.prototype = o;</span><br><span class="line">　　　 <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">　　&#125;;</span><br><span class="line">　&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>极简主义法（消除 this 和 prototype） – 调用 createNew() 得到实例对象<ul>
<li>优点：容易理解，结构清晰优雅，符合传统的”面向对象编程”的构造</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Cat = &#123;</span><br><span class="line">  age: <span class="number">3</span>, <span class="comment">// 共享数据 -- 定义在类对象内，createNew() 外</span></span><br><span class="line">  createNew: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cat = &#123;&#125;;</span><br><span class="line">    <span class="comment">// var cat = Animal.createNew(); // 继承 Animal 类</span></span><br><span class="line">    cat.name = <span class="string">"小咪"</span>;</span><br><span class="line">    <span class="keyword">var</span> sound = <span class="string">"喵喵喵"</span>; <span class="comment">// 私有属性--定义在 createNew() 内，输出对象外</span></span><br><span class="line">    cat.makeSound = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      alert(sound);  <span class="comment">// 暴露私有属性</span></span><br><span class="line">    &#125;;</span><br><span class="line">    cat.changeAge = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">      Cat.age = num; <span class="comment">// 修改共享数据</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> cat; <span class="comment">// 输出对象</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cat = Cat.createNew();</span><br><span class="line">cat.makeSound();</span><br></pre></td></tr></table></figure>


<ul>
<li>ES6 语法糖 class – 用 new 关键字 生成实例对象      </li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">     <span class="keyword">constructor</span>(x, y) &#123;</span><br><span class="line">       <span class="keyword">this</span>.x = x;</span><br><span class="line">       <span class="keyword">this</span>.y = y;</span><br><span class="line">     &#125;</span><br><span class="line">     toString() &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> point = <span class="keyword">new</span> Point(<span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p><strong>Javascript如何实现继承？</strong></p>
<ul>
<li>构造函数绑定：使用 call 或 apply 方法，将父对象的构造函数绑定在子对象上</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name,color</span>)</span>&#123;</span><br><span class="line"> 　Animal.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line"> 　<span class="keyword">this</span>.name = name;</span><br><span class="line"> 　<span class="keyword">this</span>.color = color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>实例继承：将子对象的 prototype 指向父对象的一个实例     </li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cat.prototype = <span class="keyword">new</span> Animal();</span><br><span class="line">Cat.prototype.constructor = Cat;</span><br></pre></td></tr></table></figure>

<ul>
<li>拷贝继承：如果把父对象的所有属性和方法，拷贝进子对象</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">Child, Parent</span>) </span>&#123;</span><br><span class="line">  　　　<span class="keyword">var</span> p = Parent.prototype;</span><br><span class="line">  　　　<span class="keyword">var</span> c = Child.prototype;</span><br><span class="line">  　　　<span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> p) &#123;</span><br><span class="line">  　　　   c[i] = p[i];</span><br><span class="line">  　　　&#125;</span><br><span class="line">  　　　c.uber = p;</span><br><span class="line">  　 &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>原型继承：将子对象的 prototype 指向父对象的 prototype      </li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">Child, Parent</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">  　F.prototype = Parent.prototype;</span><br><span class="line">  　Child.prototype = <span class="keyword">new</span> F();</span><br><span class="line">  　Child.prototype.constructor = Child;</span><br><span class="line">  　Child.uber = Parent.prototype;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>ES6 语法糖 extends：class ColorPoint extends Point {}</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">   <span class="keyword">constructor</span>(x, y, color) &#123;</span><br><span class="line">      <span class="keyword">super</span>(x, y); <span class="comment">// 调用父类的constructor(x, y)</span></span><br><span class="line">      <span class="keyword">this</span>.color = color;</span><br><span class="line">   &#125;</span><br><span class="line">   toString() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.color + <span class="string">' '</span> + <span class="keyword">super</span>.toString(); <span class="comment">// 调用父类的toString()</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Javascript作用链域?</strong></p>
<ul>
<li>全局函数无法查看局部函数的内部细节，但局部函数可以查看其上层的函数细节，直至全局细节</li>
<li>如果当前作用域没有找到属性或方法，会向上层作用域查找，直至全局函数，这种形式就是作用域链</li>
</ul>
<p><strong>谈谈this对象的理解</strong></p>
<ul>
<li>this 总是指向函数的直接调用者</li>
<li>如果有 new 关键字，this 指向 new 出来的实例对象</li>
<li>在事件中，this指向触发这个事件的对象</li>
<li>IE下 attachEvent 中的this总是指向全局对象Window</li>
</ul>
<p><strong>eval是做什么的？</strong></p>
<p><strong>eval的功能是把对应的字符串解析成JS代码并运行</strong></p>
<ul>
<li>应该避免使用eval，不安全，非常耗性能（先解析成js语句，再执行）</li>
<li>由JSON字符串转换为JSON对象的时候可以用 eval(‘(‘+ str +’)’);</li>
</ul>
<p><strong>什么是 Window 对象? 什么是 Document 对象?</strong></p>
<ul>
<li>Window 对象表示当前浏览器的窗口，是JavaScript的顶级对象。</li>
<li>我们创建的所有对象、函数、变量都是 Window 对象的成员。</li>
<li>Window 对象的方法和属性是在全局范围内有效的。</li>
<li>Document 对象是 HTML 文档的根节点与所有其他节点（元素节点，文本节点，属性节点, 注释节点）</li>
<li>Document 对象使我们可以通过脚本对 HTML 页面中的所有元素进行访问</li>
<li>Document 对象是 Window 对象的一部分，可通过 window.document 属性对其进行访问</li>
</ul>
<p><strong>介绍 DOM 的发展</strong></p>
<ul>
<li>DOM：文档对象模型（Document Object Model），定义了访问HTML和XML文档的标准，与编程语言及平台无关</li>
<li>DOM0：提供了查询和操作Web文档的内容API。未形成标准，实现混乱。如：document.forms[‘login’]</li>
<li>DOM1：W3C提出标准化的DOM，简化了对文档中任意部分的访问和操作。如：JavaScript中的Document对象</li>
<li>DOM2：原来DOM基础上扩充了鼠标事件等细分模块，增加了对CSS的支持。如：getComputedStyle(elem, pseudo)</li>
<li>DOM3：增加了XPath模块和加载与保存（Load and Save）模块。如：XPathEvaluator</li>
</ul>
<p><strong>介绍DOM0，DOM2，DOM3事件处理方式区别</strong></p>
<ul>
<li>DOM0级事件处理方式：<ul>
<li><code>btn.onclick = func;</code></li>
<li><code>btn.onclick = null;</code></li>
</ul>
</li>
<li>DOM2级事件处理方式：<ul>
<li><code>btn.addEventListener(&#39;click&#39;, func, false);</code></li>
<li><code>btn.removeEventListener(&#39;click&#39;, func, false);</code></li>
<li><code>btn.attachEvent(&quot;onclick&quot;, func);</code></li>
<li><code>btn.detachEvent(&quot;onclick&quot;, func);</code></li>
</ul>
</li>
<li>DOM3级事件处理方式：<ul>
<li><code>eventUtil.addListener(input, &quot;textInput&quot;, func);</code></li>
<li><code>eventUtil</code> 是自定义对象，<code>textInput</code> 是DOM3级事件</li>
</ul>
</li>
</ul>
<p><strong>事件的三个阶段</strong></p>
<ul>
<li>捕获、目标、冒泡</li>
</ul>
<p><strong>介绍事件“捕获”和“冒泡”执行顺序和事件的执行次数？</strong></p>
<ul>
<li>按照W3C标准的事件：首是进入捕获阶段，直到达到目标元素，再进入冒泡阶段</li>
<li>事件执行次数（DOM2-addEventListener）：元素上绑定事件的个数<ul>
<li>注意1：前提是事件被确实触发</li>
<li>注意2：事件绑定几次就算几个事件，即使类型和功能完全一样也不会“覆盖”</li>
</ul>
</li>
<li>事件执行顺序：判断的关键是否目标元素<ul>
<li>非目标元素：根据W3C的标准执行：捕获-&gt;目标元素-&gt;冒泡（不依据事件绑定顺序）</li>
<li>目标元素：依据事件绑定顺序：先绑定的事件先执行（不依据捕获冒泡标准）</li>
<li>最终顺序：父元素捕获-&gt;目标元素事件1-&gt;目标元素事件2-&gt;子元素捕获-&gt;子元素冒泡-&gt;父元素冒泡</li>
<li>注意：子元素事件执行前提    事件确实“落”到子元素布局区域上，而不是简单的具有嵌套关系</li>
</ul>
</li>
</ul>
<p><strong>在一个DOM上同时绑定两个点击事件：一个用捕获，一个用冒泡。事件会执行几次，先执行冒泡还是捕获？</strong></p>
<ul>
<li>该DOM上的事件如果被触发，会执行两次（执行次数等于绑定次数）</li>
<li>如果该DOM是目标元素，则按事件绑定顺序执行，不区分冒泡/捕获</li>
<li>如果该DOM是处于事件流中的非目标元素，则先执行捕获，后执行冒泡</li>
</ul>
<p><strong>事件的代理/委托</strong></p>
<ul>
<li>事件委托是指将事件绑定目标元素的到父元素上，利用冒泡机制触发该事件<ul>
<li>优点：<ul>
<li>可以减少事件注册，节省大量内存占用</li>
<li>可以将事件应用于动态添加的子元素上</li>
</ul>
</li>
<li>缺点：<br>使用不当会造成事件在不应该触发时触发</li>
<li>示例：</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ulEl.addEventListener(&apos;click&apos;, function(e)&#123;</span><br><span class="line">    var target = event.target || event.srcElement;</span><br><span class="line">    if(!!target &amp;&amp; target.nodeName.toUpperCase() === &quot;LI&quot;)&#123;</span><br><span class="line">        console.log(target.innerHTML);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, false);</span><br></pre></td></tr></table></figure>

<p><strong>IE与火狐的事件机制有什么区别？ 如何阻止冒泡？</strong></p>
<ul>
<li>IE只事件冒泡，不支持事件捕获；火狐同时支持件冒泡和事件捕获</li>
</ul>
<p><strong>IE的事件处理和W3C的事件处理有哪些区别？</strong></p>
<ul>
<li><p>绑定事件</p>
<ul>
<li>W3C: targetEl.addEventListener(‘click’, handler, false);</li>
<li>IE: targetEl.attachEvent(‘onclick’, handler);</li>
</ul>
</li>
<li><p>删除事件</p>
<ul>
<li>W3C: targetEl.removeEventListener(‘click’, handler, false);</li>
<li>IE: targetEl.detachEvent(event, handler);</li>
</ul>
</li>
<li><p>事件对象</p>
<ul>
<li>W3C: var e = arguments.callee.caller.arguments[0]</li>
<li>IE: window.event</li>
</ul>
</li>
<li><p>事件目标</p>
<ul>
<li>W3C: e.target</li>
<li>IE: window.event.srcElement</li>
</ul>
</li>
<li><p>阻止事件默认行为</p>
<ul>
<li>W3C: e.preventDefault()</li>
<li>IE: window.event.returnValue = false</li>
</ul>
</li>
<li><p>阻止事件传播</p>
<ul>
<li>W3C: e.stopPropagation()</li>
<li>IE: window.event.cancelBubble = true</li>
</ul>
</li>
</ul>
<p><strong>W3C事件的 target 与 currentTarget 的区别？</strong></p>
<ul>
<li>target 只会出现在事件流的目标阶段</li>
<li>currentTarget 可能出现在事件流的任何阶段</li>
<li>当事件流处在目标阶段时，二者的指向相同</li>
<li>当事件流处于捕获或冒泡阶段时：currentTarget 指向当前事件活动的对象(一般为父级)</li>
</ul>
<p><strong>如何派发事件(dispatchEvent)？（如何进行事件广播？）</strong></p>
<ul>
<li>W3C: 使用 dispatchEvent 方法</li>
<li>IE: 使用 fireEvent 方法</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fireEvent = <span class="function"><span class="keyword">function</span>(<span class="params">element, event</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">document</span>.createEventObject)&#123;</span><br><span class="line">        <span class="keyword">var</span> mockEvent = <span class="built_in">document</span>.createEventObject();</span><br><span class="line">        <span class="keyword">return</span> element.fireEvent(<span class="string">'on'</span> + event, mockEvent)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> mockEvent = <span class="built_in">document</span>.createEvent(<span class="string">'HTMLEvents'</span>);</span><br><span class="line">        mockEvent.initEvent(event, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> !element.dispatchEvent(mockEvent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>什么是函数节流？介绍一下应用场景和原理？</strong></p>
<ul>
<li><p>函数节流(throttle)是指阻止一个函数在很短时间间隔内连续调用。<br>只有当上一次函数执行后达到规定的时间间隔，才能进行下一次调用。<br>但要保证一个累计最小调用间隔（否则拖拽类的节流都将无连续效果）</p>
</li>
<li><p>函数节流用于 onresize, onscroll 等短时间内会多次触发的事件</p>
</li>
<li><p>函数节流的原理：使用定时器做时间节流。<br>当触发一个事件时，先用 setTimout 让这个事件延迟一小段时间再执行。<br>如果在这个时间间隔内又触发了事件，就 clearTimeout 原来的定时器，<br>再 setTimeout 一个新的定时器重复以上流程。</p>
</li>
<li><p>函数节流简单实现：</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">method, context</span>) </span>&#123;</span><br><span class="line">     clearTimeout(methor.tId);</span><br><span class="line">     method.tId = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">         method.call(context);</span><br><span class="line">     &#125;， <span class="number">100</span>); <span class="comment">// 两次调用至少间隔 100ms</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="built_in">window</span>.onresize = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    throttle(myFunc, <span class="built_in">window</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>区分什么是“客户区坐标”、“页面坐标”、“屏幕坐标”？</strong></p>
<ul>
<li>客户区坐标：鼠标指针在可视区中的水平坐标(clientX)和垂直坐标(clientY)</li>
<li>页面坐标：鼠标指针在页面布局中的水平坐标(pageX)和垂直坐标(pageY)</li>
<li>屏幕坐标：设备物理屏幕的水平坐标(screenX)和垂直坐标(screenY)</li>
</ul>
<p><strong>如何获得一个DOM元素的绝对位置？</strong></p>
<ul>
<li>elem.offsetLeft：返回元素相对于其定位父级左侧的距离</li>
<li>elem.offsetTop：返回元素相对于其定位父级顶部的距离</li>
<li>elem.getBoundingClientRect()：返回一个DOMRect对象，包含一组描述边框的只读属性，单位像素</li>
</ul>
<p><strong>分析 [‘1’, ‘2’, ‘3’].map(parseInt) 答案是多少？</strong></p>
<ul>
<li>答案:[1, NaN, NaN]</li>
</ul>
<ul>
<li>parseInt(string, radix) 第2个参数 radix 表示进制。省略 radix 或 radix = 0，则数字将以十进制解析</li>
<li>map 每次为 parseInt 传3个参数(elem, index, array)，其中 index 为数组索引</li>
<li>因此，map 遍历 [“1”, “2”, “3”]，相应 parseInt 接收参数如下</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parseInt(&apos;1&apos;, 0);  // 1</span><br><span class="line">parseInt(&apos;2&apos;, 1);  // NaN</span><br><span class="line">parseInt(&apos;3&apos;, 2);  // NaN</span><br></pre></td></tr></table></figure>

<ul>
<li>所以，parseInt 参数 radix 不合法，导致返回值为 NaN</li>
</ul>
<p><strong>new 操作符具体干了什么？</strong></p>
<ul>
<li>创建实例对象，this 变量引用该对象，同时还继承了构造函数的原型</li>
<li>属性和方法被加入到 this 引用的对象中</li>
<li>新创建的对象由 this 所引用，并且最后隐式的返回 this</li>
</ul>
<p><strong>用原生JavaScript的实现过什么功能吗？</strong></p>
<ul>
<li>封装选择器、调用第三方API、设置和获取样式</li>
</ul>
<p><strong>解释一下这段代码的意思吗？</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[].forEach.call($$(<span class="string">"*"</span>), <span class="function"><span class="keyword">function</span>(<span class="params">el</span>)</span>&#123;</span><br><span class="line">    el.style.outline = <span class="string">"1px solid #"</span> + (~~(<span class="built_in">Math</span>.random()*(<span class="number">1</span>&lt;&lt;<span class="number">24</span>))).toString(<span class="number">16</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>解释：获取页面所有的元素，遍历这些元素，为它们添加1像素随机颜色的轮廓(outline)</li>
<li><ol>
<li><code>$$(sel)</code> // $$函数被许多现代浏览器命令行支持，等价于 document.querySelectorAll(sel)</li>
</ol>
</li>
<li><ol start="2">
<li><code>[].forEach.call(NodeLists)</code> // 使用 call 函数将数组遍历函数 forEach 应到节点元素列表</li>
</ol>
</li>
<li><ol start="3">
<li><code>el.style.outline = &quot;1px solid #333&quot;</code> // 样式 outline 位于盒模型之外，不影响元素布局位置</li>
</ol>
</li>
<li><ol start="4">
<li><code>(1&lt;&lt;24)</code> // parseInt(“ffffff”, 16) == 16777215 == 2^24 - 1 // 1&lt;&lt;24 == 2^24 == 16777216</li>
</ol>
</li>
<li><ol start="5">
<li><code>Math.random()*(1&lt;&lt;24)</code> // 表示一个位于 0 到 16777216 之间的随机浮点数</li>
</ol>
</li>
<li><ol start="6">
<li><code>~~Math.random()*(1&lt;&lt;24)</code> // <code>~~</code> 作用相当于 parseInt 取整</li>
</ol>
</li>
<li><ol start="7">
<li><code>(~~(Math.random()*(1&lt;&lt;24))).toString(16)</code> // 转换为一个十六进制- </li>
</ol>
</li>
</ul>
<p>** JavaScript实现异步编程的方法？**</p>
<ul>
<li>回调函数</li>
<li>事件监听</li>
<li>发布/订阅</li>
<li>Promises对象</li>
<li>Async函数[ES7]</li>
</ul>
<p><strong>web开发中会话跟踪的方法有哪些</strong></p>
<ul>
<li>cookie</li>
<li>session</li>
<li>url重写</li>
<li>隐藏input</li>
<li>ip地址</li>
</ul>
<p><strong>介绍js的基本数据类型</strong></p>
<ul>
<li>Undefined、Null、Boolean、Number、String</li>
</ul>
<p><strong>介绍js有哪些内置对象？</strong></p>
<ul>
<li>Object 是 JavaScript 中所有对象的父对象</li>
<li>数据封装类对象：Object、Array、Boolean、Number 和 String</li>
<li>其他对象：Function、Arguments、Math、Date、RegExp、Error</li>
</ul>
<p><strong>说几条写JavaScript的基本规范？</strong></p>
<ul>
<li>不要在同一行声明多个变量</li>
<li>请使用 ===/!==来比较true/false或者数值</li>
<li>使用对象字面量替代new Array这种形式</li>
<li>不要使用全局函数</li>
<li>Switch语句必须带有default分支</li>
<li>函数不应该有时候有返回值，有时候没有返回值</li>
<li>If语句必须使用大括号</li>
<li>for-in循环中的变量 应该使用var关键字明确限定作用域，从而避免作用域污</li>
</ul>
<p><strong>JavaScript原型，原型链 ? 有什么特点？</strong></p>
<ul>
<li><p>每个对象都会在其内部初始化一个属性，就是prototype(原型)，当我们访问一个对象的属性时</p>
</li>
<li><p>如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，于是就这样一直找下去，也就是我们平时所说的原型链的概念</p>
</li>
<li><p>关系：<code>instance.constructor.prototype = instance.__proto__</code></p>
</li>
<li><p>特点：</p>
<ul>
<li>JavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。</li>
</ul>
</li>
<li><p>当我们需要一个属性的时，Javascript引擎会先看当前对象中是否有这个属性， 如果没有的</p>
</li>
<li><p>就会查找他的Prototype对象是否有这个属性，如此递推下去，一直检索到 Object 内建对象</p>
</li>
</ul>
<p><strong>JavaScript有几种类型的值？，你能画一下他们的内存图吗？</strong></p>
<ul>
<li><p>栈：原始数据类型（Undefined，Null，Boolean，Number、String） </p>
</li>
<li><p>堆：引用数据类型（对象、数组和函数）</p>
</li>
<li><p>两种类型的区别是：存储位置不同；</p>
</li>
<li><p>原始数据类型直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；</p>
</li>
<li><p>引用数据类型存储在堆(heap)中的对象,占据空间大、大小不固定,如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其</p>
</li>
<li><p>在栈中的地址，取得地址后从堆中获得实体</p>
</li>
</ul>
<p><img src="https://camo.githubusercontent.com/d1947e624a0444d1032a85800013df487adc5550/687474703a2f2f7777772e77337363686f6f6c2e636f6d2e636e2f692f63745f6a735f76616c75652e676966" alt></p>
<p><strong>Javascript如何实现继承？</strong></p>
<ul>
<li><p>构造继承</p>
</li>
<li><p>原型继承</p>
</li>
<li><p>实例继承</p>
</li>
<li><p>拷贝继承</p>
</li>
<li><p>原型prototype机制或apply和call方法去实现较简单，建议使用构造函数与原型混合方式</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function Parent()&#123;</span><br><span class="line">       this.name = &apos;wang&apos;;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   function Child()&#123;</span><br><span class="line">       this.age = 28;</span><br><span class="line">   &#125;</span><br><span class="line">   Child.prototype = new Parent();//继承了Parent，通过原型</span><br><span class="line"></span><br><span class="line">   var demo = new Child();</span><br><span class="line">   alert(demo.age);</span><br><span class="line">   alert(demo.name);//得到被继承的属性</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>javascript创建对象的几种方式？</strong></p>
<blockquote>
<p>javascript创建对象简单的说,无非就是使用内置对象或各种自定义对象，当然还可以用JSON；但写法有很多种，也能混合使用</p>
</blockquote>
<ul>
<li>对象字面量的方式</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person=&#123;firstname:&quot;Mark&quot;,lastname:&quot;Yun&quot;,age:25,eyecolor:&quot;black&quot;&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>用function来模拟无参的构造函数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> function Person()&#123;&#125;</span><br><span class="line">    var person=new Person();//定义一个function，如果使用new&quot;实例化&quot;,该function可以看作是一个Class</span><br><span class="line">        person.name=&quot;Mark&quot;;</span><br><span class="line">        person.age=&quot;25&quot;;</span><br><span class="line">        person.work=function()&#123;</span><br><span class="line">        alert(person.name+&quot; hello...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">person.work();</span><br></pre></td></tr></table></figure>

<ul>
<li>用function来模拟参构造函数来实现（用this关键字定义构造的上下文属性）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Pet(name,age,hobby)&#123;</span><br><span class="line">       this.name=name;//this作用域：当前对象</span><br><span class="line">       this.age=age;</span><br><span class="line">       this.hobby=hobby;</span><br><span class="line">       this.eat=function()&#123;</span><br><span class="line">          alert(&quot;我叫&quot;+this.name+&quot;,我喜欢&quot;+this.hobby+&quot;,是个程序员&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    var maidou =new Pet(&quot;麦兜&quot;,25,&quot;coding&quot;);//实例化、创建对象</span><br><span class="line">    maidou.eat();//调用eat方法</span><br></pre></td></tr></table></figure>

<ul>
<li>用工厂方式来创建（内置对象）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var wcDog =new Object();</span><br><span class="line">     wcDog.name=&quot;旺财&quot;;</span><br><span class="line">     wcDog.age=3;</span><br><span class="line">     wcDog.work=function()&#123;</span><br><span class="line">       alert(&quot;我是&quot;+wcDog.name+&quot;,汪汪汪......&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">     wcDog.work();</span><br></pre></td></tr></table></figure>

<ul>
<li>用原型方式来创建</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Dog()&#123;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line">     Dog.prototype.name=&quot;旺财&quot;;</span><br><span class="line">     Dog.prototype.eat=function()&#123;</span><br><span class="line">     alert(this.name+&quot;是个吃货&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">     var wangcai =new Dog();</span><br><span class="line">     wangcai.eat();</span><br></pre></td></tr></table></figure>

<ul>
<li>用混合方式来创建</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Car(name,price)&#123;</span><br><span class="line">     this.name=name;</span><br><span class="line">     this.price=price; </span><br><span class="line">   &#125;</span><br><span class="line">    Car.prototype.sell=function()&#123;</span><br><span class="line">      alert(&quot;我是&quot;+this.name+&quot;，我现在卖&quot;+this.price+&quot;万元&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">   var camry =new Car(&quot;凯美瑞&quot;,27);</span><br><span class="line">   camry.sell();</span><br></pre></td></tr></table></figure>

<p><strong>Javascript作用链域?</strong></p>
<ul>
<li>全局函数无法查看局部函数的内部细节，但局部函数可以查看其上层的函数细节，直至全局细节</li>
<li>当需要从局部函数查找某一属性或方法时，如果当前作用域没有找到，就会上溯到上层作用域查找</li>
<li>直至全局函数，这种组织形式就是作用域链</li>
</ul>
<p><strong>谈谈This对象的理解</strong></p>
<ul>
<li>this总是指向函数的直接调用者（而非间接调用者）</li>
<li>如果有new关键字，this指向new出来的那个对象</li>
<li>在事件中，this指向触发这个事件的对象，特殊的是，IE中的attachEvent中的this总是指向全局对象Window</li>
</ul>
<p><strong>eval是做什么的？</strong></p>
<ul>
<li>它的功能是把对应的字符串解析成JS代码并运行</li>
<li>应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）</li>
<li>由JSON字符串转换为JSON对象的时候可以用eval，var obj =eval(‘(‘+ str +’)’)</li>
</ul>
<p><strong>null，undefined 的区别？</strong></p>
<ul>
<li><p>undefined   表示不存在这个值。</p>
</li>
<li><p>undefined :是一个表示”无”的原始值或者说表示”缺少值”，就是此处应该有一个值，但是还没有定义。当尝试读取时会返回 undefined</p>
</li>
<li><p>例如变量被声明了，但没有赋值时，就等于undefined</p>
</li>
<li><p>null 表示一个对象被定义了，值为“空值”</p>
</li>
<li><p>null : 是一个对象(空对象, 没有任何属性和方法)</p>
</li>
<li><p>例如作为函数的参数，表示该函数的参数不是对象；</p>
</li>
<li><p>在验证null时，一定要使用　=== ，因为 == 无法分别 null 和　undefined</p>
</li>
</ul>
<p><strong>写一个通用的事件侦听器函数</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">// event(事件)工具集，来源：github.com/markyun</span><br><span class="line">   markyun.Event = &#123;</span><br><span class="line">       // 页面加载完成后</span><br><span class="line">       readyEvent : function(fn) &#123;</span><br><span class="line">           if (fn==null) &#123;</span><br><span class="line">               fn=document;</span><br><span class="line">           &#125;</span><br><span class="line">           var oldonload = window.onload;</span><br><span class="line">           if (typeof window.onload != &apos;function&apos;) &#123;</span><br><span class="line">               window.onload = fn;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               window.onload = function() &#123;</span><br><span class="line">                   oldonload();</span><br><span class="line">                   fn();</span><br><span class="line">               &#125;;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;,</span><br><span class="line">       // 视能力分别使用dom0||dom2||IE方式 来绑定事件</span><br><span class="line">       // 参数： 操作的元素,事件名称 ,事件处理程序</span><br><span class="line">       addEvent : function(element, type, handler) &#123;</span><br><span class="line">           if (element.addEventListener) &#123;</span><br><span class="line">               //事件类型、需要执行的函数、是否捕捉</span><br><span class="line">               element.addEventListener(type, handler, false);</span><br><span class="line">           &#125; else if (element.attachEvent) &#123;</span><br><span class="line">               element.attachEvent(&apos;on&apos; + type, function() &#123;</span><br><span class="line">                   handler.call(element);</span><br><span class="line">               &#125;);</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               element[&apos;on&apos; + type] = handler;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;,</span><br><span class="line">       // 移除事件</span><br><span class="line">       removeEvent : function(element, type, handler) &#123;</span><br><span class="line">           if (element.removeEventListener) &#123;</span><br><span class="line">               element.removeEventListener(type, handler, false);</span><br><span class="line">           &#125; else if (element.datachEvent) &#123;</span><br><span class="line">               element.detachEvent(&apos;on&apos; + type, handler);</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               element[&apos;on&apos; + type] = null;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;,</span><br><span class="line">       // 阻止事件 (主要是事件冒泡，因为IE不支持事件捕获)</span><br><span class="line">       stopPropagation : function(ev) &#123;</span><br><span class="line">           if (ev.stopPropagation) &#123;</span><br><span class="line">               ev.stopPropagation();</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               ev.cancelBubble = true;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;,</span><br><span class="line">       // 取消事件的默认行为</span><br><span class="line">       preventDefault : function(event) &#123;</span><br><span class="line">           if (event.preventDefault) &#123;</span><br><span class="line">               event.preventDefault();</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               event.returnValue = false;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;,</span><br><span class="line">       // 获取事件目标</span><br><span class="line">       getTarget : function(event) &#123;</span><br><span class="line">           return event.target || event.srcElement;</span><br><span class="line">       &#125;,</span><br><span class="line">       // 获取event对象的引用，取到事件的所有信息，确保随时能使用event；</span><br><span class="line">       getEvent : function(e) &#123;</span><br><span class="line">           var ev = e || window.event;</span><br><span class="line">           if (!ev) &#123;</span><br><span class="line">               var c = this.getEvent.caller;</span><br><span class="line">               while (c) &#123;</span><br><span class="line">                   ev = c.arguments[0];</span><br><span class="line">                   if (ev &amp;&amp; Event == ev.constructor) &#123;</span><br><span class="line">                       break;</span><br><span class="line">                   &#125;</span><br><span class="line">                   c = c.caller;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           return ev;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>

<p><strong>[“1”, “2”, “3”].map(parseInt) 答案是多少？</strong></p>
<ul>
<li>[1, NaN, NaN] 因为 parseInt 需要两个参数 (val, radix)，其中 radix 表示解析时用的基数。</li>
<li>map 传了 3 个 (element, index, array)，对应的 radix 不合法导致解析失败。</li>
</ul>
<p><strong>事件是？IE与火狐的事件机制有什么区别？ 如何阻止冒泡？</strong></p>
<ul>
<li>我们在网页中的某个操作（有的操作对应多个事件）。例如：当我们点击一个按钮就会产生一个事件。是可以被 JavaScript 侦测到的行为</li>
<li>事件处理机制：IE是事件冒泡、Firefox同时支持两种事件模型，也就是：捕获型事件和冒泡型事件</li>
<li>ev.stopPropagation();（旧ie的方法 ev.cancelBubble = true;）</li>
</ul>
<p><strong>什么是闭包（closure），为什么要用它？</strong></p>
<ul>
<li><p>闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域</p>
</li>
<li><p>闭包的特性：</p>
<ul>
<li>函数内再嵌套函数</li>
<li>内部函数可以引用外层的参数和变量</li>
<li>参数和变量不会被垃圾回收机制回收</li>
</ul>
</li>
</ul>
<p><strong>javascript 代码中的”use strict”;是什么意思 ? 使用它区别是什么？</strong></p>
<ul>
<li>use strict是一种ECMAscript 5 添加的（严格）运行模式,这种模式使得 Javascript 在更严格的条件下运行,使JS编码更加规范化的模式,消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为</li>
</ul>
<p><strong>如何判断一个对象是否属于某个类？</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 使用instanceof （待完善）</span><br><span class="line">   if(a instanceof Person)&#123;</span><br><span class="line">       alert(&apos;yes&apos;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>new操作符具体干了什么呢?</strong></p>
<ul>
<li>创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型</li>
<li>属性和方法被加入到 this 引用的对象中</li>
<li>新创建的对象由 this 所引用，并且最后隐式的返回 this</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var obj  = &#123;&#125;;</span><br><span class="line">obj.__proto__ = Base.prototype;</span><br><span class="line">Base.call(obj);</span><br></pre></td></tr></table></figure>

<p><strong>js延迟加载的方式有哪些？</strong></p>
<ul>
<li>defer和async、动态创建DOM方式（用得最多）、按需异步载入js</li>
</ul>
<p><strong>Ajax 是什么? 如何创建一个Ajax？</strong></p>
<blockquote>
<p>ajax的全称：Asynchronous Javascript And XML</p>
</blockquote>
<ul>
<li><p>异步传输+js+xml</p>
</li>
<li><p>所谓异步，在这里简单地解释就是：向服务器发送请求的时候，我们不必等待结果，而是可以同时做其他的事情，等到有了结果它自己会根据设定进行后续操作，与此同时，页面是不会发生整页刷新的，提高了用户体验</p>
</li>
<li><p>创建XMLHttpRequest对象,也就是创建一个异步调用对象</p>
</li>
<li><p>建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息</p>
</li>
<li><p>设置响应HTTP请求状态变化的函数</p>
</li>
<li><p>发送HTTP请求</p>
</li>
<li><p>获取异步调用返回的数据</p>
</li>
<li><p>用JavaScript和DOM实现局部刷新</p>
</li>
</ul>
<p><strong>同步和异步的区别?</strong></p>
<ul>
<li>同步：浏览器访问服务器请求，用户看得到页面刷新，重新发请求,等请求完，页面刷新，新内容出现，用户看到新内容,进行下一步操作</li>
<li>异步：浏览器访问服务器请求，用户正常操作，浏览器后端进行请求。等请求完，页面不刷新，新内容也会出现，用户看到新内容</li>
</ul>
<p><strong>异步加载JS的方式有哪些？</strong></p>
<ul>
<li>defer，只支持IE</li>
<li>async：</li>
<li>创建script，插入到DOM中，加载完毕后callBack</li>
</ul>
<p><strong>documen.write和 innerHTML的区别</strong></p>
<ul>
<li>document.write只能重绘整个页面</li>
<li>innerHTML可以重绘页面的一部分</li>
</ul>
<p><strong>DOM操作——怎样添加、移除、移动、复制、创建和查找节点?</strong></p>
<ul>
<li>（1）创建新节点<ul>
<li>createDocumentFragment() //创建一个DOM片段</li>
<li>createElement()   //创建一个具体的元素</li>
<li>createTextNode()   //创建一个文本节点</li>
</ul>
</li>
<li>（2）添加、移除、替换、插入<ul>
<li>appendChild()</li>
<li>removeChild()</li>
<li>replaceChild()</li>
<li>insertBefore() //在已有的子节点前插入一个新的子节点</li>
</ul>
</li>
<li>（3）查找<ul>
<li>getElementsByTagName()    //通过标签名称</li>
<li>getElementsByName()    // 通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的)</li>
<li>getElementById()    //通过元素Id，唯一性</li>
</ul>
</li>
</ul>
<p><strong>那些操作会造成内存泄漏？</strong></p>
<ul>
<li>内存泄漏指任何对象在您不再拥有或需要它之后仍然存在</li>
<li>垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收</li>
<li>setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏</li>
<li>闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）</li>
</ul>
<p><strong>渐进增强和优雅降级</strong></p>
<ul>
<li><p>渐进增强 ：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。</p>
</li>
<li><p>优雅降级 ：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容</p>
</li>
</ul>
<p><strong>Javascript垃圾回收方法</strong></p>
<ul>
<li>标记清除（mark and sweep）</li>
</ul>
<blockquote>
<ul>
<li>这是JavaScript最常见的垃圾回收方式，当变量进入执行环境的时候，比如函数中声明一个变量，垃圾回收器将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为“离开环境”</li>
<li>垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，然后去掉环境中的变量以及被环境中变量所引用的变量（闭包），在这些完成之后仍存在标记的就是要删除的变量了</li>
</ul>
</blockquote>
<p><strong>引用计数(reference counting)</strong></p>
<blockquote>
<p>在低版本IE中经常会出现内存泄露，很多时候就是因为其采用引用计数方式进行垃圾回收。引用计数的策略是跟踪记录每个值被使用的次数，当声明了一个 变量并将一个引用类型赋值给该变量的时候这个值的引用次数就加1，如果该变量的值变成了另外一个，则这个值得引用次数减1，当这个值的引用次数变为0的时 候，说明没有变量在使用，这个值没法被访问了，因此可以将其占用的空间回收，这样垃圾回收器会在运行的时候清理掉引用次数为0的值占用的空间</p>
</blockquote>
<p><strong>js继承方式及其优缺点</strong></p>
<ul>
<li><p>原型链继承的缺点</p>
<ul>
<li>一是字面量重写原型会中断关系，使用引用类型的原型，并且子类型还无法给超类型传递参数。</li>
</ul>
</li>
<li><p>借用构造函数（类式继承）</p>
<ul>
<li>借用构造函数虽然解决了刚才两种问题，但没有原型，则复用无从谈起。所以我们需要原型链+借用构造函数的模式，这种模式称为组合继承</li>
</ul>
</li>
<li><p>组合式继承</p>
<ul>
<li>组合式继承是比较常用的一种继承方法，其背后的思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又保证每个实例都有它自己的属性。</li>
</ul>
</li>
</ul>
<p><strong>defer和async</strong></p>
<ul>
<li>defer并行加载js文件，会按照页面上script标签的顺序执行async并行加载js文件，下载完成立即执行，不会按照页面上script标签的顺序执行</li>
</ul>
<p><strong>用过哪些设计模式？</strong></p>
<ul>
<li><p>工厂模式：</p>
<ul>
<li>主要好处就是可以消除对象间的耦合，通过使用工程方法而不是new关键字。将所有实例化的代码集中在一个位置防止代码重复</li>
<li>工厂模式解决了重复实例化的问题 ，但还有一个问题,那就是识别问题，因为根本无法 搞清楚他们到底是哪个对象的实例</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function createObject(name,age,profession)&#123;//集中实例化的函数var obj = new Object();</span><br><span class="line">    obj.name = name;</span><br><span class="line">    obj.age = age;</span><br><span class="line">    obj.profession = profession;</span><br><span class="line">    obj.move = function () &#123;</span><br><span class="line">        return this.name + &apos; at &apos; + this.age + &apos; engaged in &apos; + this.profession;</span><br><span class="line">    &#125;;</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br><span class="line">var test1 = createObject(&apos;trigkit4&apos;,22,&apos;programmer&apos;);//第一个实例var test2 = createObject(&apos;mike&apos;,25,&apos;engineer&apos;);//第二个实例</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>构造函数模式</p>
<ul>
<li>使用构造函数的方法 ，即解决了重复实例化的问题 ，又解决了对象识别的问题，该模式与工厂模式的不同之处在于</li>
</ul>
</li>
<li><p>构造函数方法没有显示的创建对象 (new Object());</p>
</li>
<li><p>直接将属性和方法赋值给 this 对象;</p>
</li>
<li><p>没有 renturn 语句</p>
</li>
</ul>
<p><strong>说说你对闭包的理解</strong></p>
<ul>
<li><p>使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。在js中，函数即闭包，只有函数才会产生作用域的概念</p>
</li>
<li><p>闭包有三个特性：</p>
<ul>
<li><p>1.函数嵌套函数</p>
</li>
<li><p>2.函数内部可以引用外部的参数和变量</p>
</li>
<li><p>3.参数和变量不会被垃圾回收机制回收</p>
</li>
</ul>
</li>
</ul>
<p><strong>请解释一下 JavaScript 的同源策略</strong></p>
<ul>
<li>概念:同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议</li>
<li>指一段脚本只能读取来自同一来源的窗口和文档的属性</li>
</ul>
<p><strong>为什么要有同源限制？</strong></p>
<ul>
<li>我们举例说明：比如一个黑客程序，他利用Iframe把真正的银行登录页面嵌到他的页面上，当你使用真实的用户名，密码登录时，他的页面就可以通过Javascript读取到你的表单中input中的内容，这样用户名，密码就轻松到手了。</li>
<li>缺点<ul>
<li>现在网站的JS都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严格模式的文件，被 merge后，这个串就到了文件的中间，不仅没有指示严格模式，反而在压缩后浪费了字节</li>
</ul>
</li>
</ul>
<p><strong>实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.clone = function()&#123;</span><br><span class="line"></span><br><span class="line">            var o = this.constructor === Array ? [] : &#123;&#125;;</span><br><span class="line"></span><br><span class="line">            for(var e in this)&#123;</span><br><span class="line"></span><br><span class="line">                    o[e] = typeof this[e] === &quot;object&quot; ? this[e].clone() : this[e];</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return o;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>说说严格模式的限制</strong></p>
<ul>
<li><p>严格模式主要有以下限制：</p>
</li>
<li><p>变量必须声明后再使用</p>
</li>
<li><p>函数的参数不能有同名属性，否则报错</p>
</li>
<li><p>不能使用with语句</p>
</li>
<li><p>不能对只读属性赋值，否则报错</p>
</li>
<li><p>不能使用前缀0表示八进制数，否则报错</p>
</li>
<li><p>不能删除不可删除的属性，否则报错</p>
</li>
<li><p>不能删除变量delete prop，会报错，只能删除属性delete global[prop]</p>
</li>
<li><p>eval不会在它的外层作用域引入变量</p>
</li>
<li><p>eval和arguments不能被重新赋值</p>
</li>
<li><p>arguments不会自动反映函数参数的变化</p>
</li>
<li><p>不能使用arguments.callee</p>
</li>
<li><p>不能使用arguments.caller</p>
</li>
<li><p>禁止this指向全局对象</p>
</li>
<li><p>不能使用fn.caller和fn.arguments获取函数调用的堆栈</p>
</li>
<li><p>增加了保留字（比如protected、static和interface）</p>
</li>
</ul>
<p><strong>如何删除一个cookie</strong></p>
<ul>
<li>将时间设为当前时间往前一点</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var date = new Date();</span><br><span class="line"></span><br><span class="line">date.setDate(date.getDate() - 1);//真正的删除</span><br></pre></td></tr></table></figure>

<p>setDate()方法用于设置一个月的某一天</p>
<ul>
<li>expires的设置</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.cookie = &apos;user=&apos;+ encodeURIComponent(&apos;name&apos;)  + &apos;;expires = &apos; + new Date(0)</span><br></pre></td></tr></table></figure>

<p><strong>编写一个方法 求一个字符串的字节长度</strong></p>
<ul>
<li>假设：一个英文字符占用一个字节，一个中文字符占用两个字节    </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function GetBytes(str)&#123;</span><br><span class="line"></span><br><span class="line">        var len = str.length;</span><br><span class="line"></span><br><span class="line">        var bytes = len;</span><br><span class="line"></span><br><span class="line">        for(var i=0; i&lt;len; i++)&#123;</span><br><span class="line"></span><br><span class="line">            if (str.charCodeAt(i) &gt; 255) bytes++;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return bytes;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">alert(GetBytes(&quot;你好,as&quot;));</span><br></pre></td></tr></table></figure>

<p><strong>请解释什么是事件代理</strong></p>
<ul>
<li>事件代理（Event Delegation），又称之为事件委托。是 JavaScript 中常用绑定事件的常用技巧。顾名思义，“事件代理”即是把原本需要绑定的事件委托给父元素，让父元素担当事件监听的职务。事件代理的原理是DOM元素的事件冒泡。使用事件代理的好处是可以提高性能</li>
</ul>
<p><strong>attribute和property的区别是什么？</strong></p>
<ul>
<li><p>attribute是dom元素在文档中作为html标签拥有的属性；</p>
</li>
<li><p>property就是dom元素在js中作为对象拥有的属性。</p>
</li>
<li><p>对于html的标准属性来说，attribute和property是同步的，是会自动更新的</p>
</li>
<li><p>但是对于自定义的属性来说，他们是不同步的</p>
</li>
</ul>
<p><strong>页面编码和被请求的资源编码如果不一致如何处理？</strong></p>
<ul>
<li>后端响应头设置 charset </li>
<li>前端页面<code>&lt;meta&gt;</code>设置 charset</li>
</ul>
<p><strong>把<code>&lt;script&gt;</code>放在<code>&lt;/body&gt;</code>之前和之后有什么区别？浏览器会如何解析它们？</strong></p>
<ul>
<li>按照HTML标准，在<code>&lt;/body&gt;</code>结束后出现<code>&lt;script&gt;</code>或任何元素的开始标签，都是解析错误</li>
<li>虽然不符合HTML标准，但浏览器会自动容错，使实际效果与写在<code>&lt;/body&gt;</code>之前没有区别</li>
<li>浏览器的容错机制会忽略<script>之前的<code>&lt;/body&gt;</code>，视作<code>&lt;script&gt;</code>仍在 body 体内。省略<code>&lt;/body&gt;</code>和<code>&lt;/html&gt;</code>闭合标签符合HTML标准，服务器可以利用这一标准尽可能少输出内容</li>
</ul>
<p><strong>延迟加载JS的方式有哪些？</strong></p>
<ul>
<li>设置<code>&lt;script&gt;</code>属性 defer="defer" （脚本将在页面完成解析时执行）</li>
<li>动态创建 script DOM：document.createElement('script');</li>
<li>XmlHttpRequest 脚本注入</li>
<li>延迟加载工具 LazyLoad</li>
</ul>
<p><strong>异步加载JS的方式有哪些？</strong></p>
<ul>
<li>设置<code>&lt;script&gt;</code>属性 async="async" （一旦脚本可用，则会异步执行）</li>
<li>动态创建 script DOM：document.createElement('script');</li>
<li>XmlHttpRequest 脚本注入</li>
<li>异步加载库 LABjs</li>
<li>模块加载器 Sea.js</li>
</ul>
<p><strong>JavaScript 中，调用函数有哪几种方式？</strong></p>
<ul>
<li>方法调用模式          Foo.foo(arg1, arg2);</li>
<li>函数调用模式          foo(arg1, arg2);</li>
<li>构造器调用模式        (new Foo())(arg1, arg2);</li>
<li>call/applay调用模式   Foo.foo.call(that, arg1, arg2);</li>
<li>bind调用模式          Foo.foo.bind(that)(arg1, arg2)();</li>
</ul>
<p><strong>简单实现 Function.bind 函数？</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Function</span>.prototype.bind) &#123;</span><br><span class="line">  <span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params">that</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> func = <span class="keyword">this</span>, args = <span class="built_in">arguments</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> func.apply(that, <span class="built_in">Array</span>.prototype.slice.call(args, <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 只支持 bind 阶段的默认参数：</span></span><br><span class="line">func.bind(that, arg1, arg2)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不支持以下调用阶段传入的参数：</span></span><br><span class="line">func.bind(that)(arg1, arg2);</span><br></pre></td></tr></table></figure>

<p>** 列举一下JavaScript数组和对象有哪些原生方法？**</p>
<ul>
<li><p>数组：</p>
<ul>
<li>arr.concat(arr1, arr2, arrn);</li>
<li>arr.join(",");</li>
<li>arr.sort(func);</li>
<li>arr.pop();</li>
<li>arr.push(e1, e2, en);</li>
<li>arr.shift();</li>
<li>unshift(e1, e2, en);</li>
<li>arr.reverse();</li>
<li>arr.slice(start, end);            </li>
<li>arr.splice(index, count, e1, e2, en);  </li>
<li>arr.indexOf(el);</li>
<li>arr.includes(el);   // ES6</li>
</ul>
</li>
<li><p>对象：</p>
<ul>
<li>object.hasOwnProperty(prop);     </li>
<li>object.propertyIsEnumerable(prop);</li>
<li>object.valueOf();                 </li>
<li>object.toString();                </li>
<li>object.toLocaleString();          </li>
<li>Class.prototype.isPropertyOf(object);  </li>
</ul>
</li>
</ul>
<p><strong>Array.splice() 与 Array.splice() 的区别？</strong></p>
<ul>
<li><p>slice -- “读取”数组指定的元素，不会对原数组进行修改</p>
<ul>
<li>语法：arr.slice(start, end)</li>
<li>start 指定选取开始位置（含）</li>
<li>end 指定选取结束位置（不含）</li>
</ul>
<ul>
<li>splice <ul>
<li>“操作”数组指定的元素，会修改原数组，返回被删除的元素</li>
<li>语法：arr.splice(index, count, [insert Elements])</li>
<li>index 是操作的起始位置</li>
<li>count = 0 插入元素，count > 0 删除元素</li>
<li>[insert Elements] 向数组新插入的元素</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>JavaScript 对象生命周期的理解？</strong></p>
<ul>
<li>当创建一个对象时，JavaScript 会自动为该对象分配适当的内存</li>
<li>垃圾回收器定期扫描对象，并计算引用了该对象的其他对象的数量</li>
<li>如果被引用数量为 0，或惟一引用是循环的，那么该对象的内存即可回收</li>
</ul>
<p><strong>哪些操作会造成内存泄漏？</strong></p>
<ul>
<li><p>JavaScript 内存泄露指对象在不需要使用它时仍然存在，导致占用的内存不能使用或回收</p>
</li>
<li><p>未使用 var 声明的全局变量</p>
</li>
<li><p>闭包函数(Closures)</p>
</li>
<li><p>循环引用(两个对象相互引用)</p>
</li>
<li><p>控制台日志(console.log)</p>
</li>
<li><p>移除存在绑定事件的DOM元素(IE)</p>
</li>
</ul>
</script></li></ul>
      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  
  
  

</article>
    
    <article id="post-HTTP协议" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    

    
    <div class="article-meta">
      <a href="/2020/04/16/HTTP协议/" class="article-date">
  <time datetime="2020-04-15T17:37:00.036Z" itemprop="datePublished">2020-04-16</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <p>一面中，如果有笔试，考HTTP协议的可能性较大。</p>
<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>一面要讲的内容：</p>
<ul>
<li><code>HTTP</code>协议的主要特点</li>
<li><code>HTTP</code>报文的组成部分</li>
<li><code>HTTP</code>方法</li>
<li><code>get</code> 和 <code>post</code>的区别</li>
<li><code>HTTP</code>状态码</li>
<li>什么是持久连接</li>
<li>什么是管线化</li>
</ul>
<p>二面要讲的内容；</p>
<ul>
<li>缓存</li>
<li><code>CSRF</code>攻击</li>
</ul>
<h2 id="2-HTTP协议的主要特点"><a href="#2-HTTP协议的主要特点" class="headerlink" title="2. HTTP协议的主要特点"></a>2. HTTP协议的主要特点</h2><ul>
<li>简单快速</li>
<li>灵活</li>
<li><strong>无连接</strong></li>
<li><strong>无状态</strong></li>
</ul>
<blockquote>
<p>通常我们要答出以上四个内容。如果实在记不住，一定要记得后面的两个：<strong>无连接、无状态</strong>。</p>
</blockquote>
<p>我们分别来解释一下。</p>
<h3 id="2-1-简单快速"><a href="#2-1-简单快速" class="headerlink" title="2.1 简单快速"></a>2.1 简单快速</h3><blockquote>
<p><strong>简单</strong>：每个资源（比如图片、页面）都通过 url 来定位。这都是固定的，在<code>http</code>协议中，处理起来也比较简单，想访问什么资源，直接输入url即可。</p>
</blockquote>
<h3 id="2-2-灵活"><a href="#2-2-灵活" class="headerlink" title="2.2 灵活"></a>2.2 灵活</h3><blockquote>
<p><code>http</code>协议的头部有一个<code>数据类型</code>，通过<code>http</code>协议，就可以完成不同数据类型的传输。</p>
</blockquote>
<h3 id="2-3-无连接"><a href="#2-3-无连接" class="headerlink" title="2.3 无连接"></a>2.3 无连接</h3><blockquote>
<p>连接一次，就会断开，不会继续保持连接。</p>
</blockquote>
<h3 id="2-4-无状态"><a href="#2-4-无状态" class="headerlink" title="2.4 无状态"></a>2.4 无状态</h3><blockquote>
<p>客户端和服务器端是两种身份。第一次请求结束后，就断开了，第二次请求时，<strong>服务器端并没有记住之前的状态</strong>，也就是说，服务器端无法区分客户端是否为同一个人、同一个身份。</p>
</blockquote>
<blockquote>
<p>有的时候，我们访问网站时，网站能记住我们的账号，这个是通过其他的手段（比如 <code>session</code>）做到的，并不是<code>http</code>协议能做到的。</p>
</blockquote>
<h2 id="3-HTTP报文的组成部分"><a href="#3-HTTP报文的组成部分" class="headerlink" title="3 HTTP报文的组成部分"></a>3 HTTP报文的组成部分</h2><p><img src="http://img.smyhvae.com/20180306_1400.png" alt></p>
<blockquote>
<p>在回答此问题时，我们要按照顺序回答：</p>
</blockquote>
<ul>
<li>先回答的是，<code>http</code>报文包括：<strong>请求报文</strong>和<strong>响应报文</strong>。</li>
<li>再回答的是，每个报文包含什么部分。</li>
<li>最后回答，每个部分的内容是什么</li>
</ul>
<h3 id="3-1-请求报文包括："><a href="#3-1-请求报文包括：" class="headerlink" title="3.1 请求报文包括："></a>3.1 请求报文包括：</h3><p><img src="http://img.smyhvae.com/20180228_1505.jpg" alt></p>
<ul>
<li>请求行：包括请求方法、请求的<code>url</code>、<code>http</code>协议及版本。</li>
<li>请求头：一大堆的键值对。</li>
<li><strong>空行</strong>指的是：当服务器在解析请求头的时候，如果遇到了空行，则表明，后面的内容是请求体</li>
<li>请求体：数据部分。</li>
</ul>
<h3 id="3-2-响应报文包括："><a href="#3-2-响应报文包括：" class="headerlink" title="3.2 响应报文包括："></a>3.2 响应报文包括：</h3><p><img src="http://img.smyhvae.com/20180228_1510.jpg" alt></p>
<ul>
<li>状态行：<code>http</code>协议及版本、状态码及状态描述。</li>
<li>响应头</li>
<li>空行</li>
<li>响应体</li>
</ul>
<h2 id="4-HTTP方法"><a href="#4-HTTP方法" class="headerlink" title="4 HTTP方法"></a>4 HTTP方法</h2><p>包括：</p>
<ul>
<li><code>GET</code>：获取资源</li>
<li><code>POST</code>：传输资源</li>
<li><code>put</code>：更新资源</li>
<li><code>DELETE</code>：删除资源</li>
<li><code>HEAD</code>：获得报文首部</li>
</ul>
<blockquote>
<p><code>HTTP</code>方法有很多，但是上面这五个方法，要求在面试时全部说出来，不要漏掉。</p>
</blockquote>
<ul>
<li><code>get</code> <code>和</code>post` 比较常见。</li>
<li><code>put</code> 和 <code>delete</code> 在实际应用中用的很少。况且，业务中，一般不删除服务器端的资源。</li>
<li><code>head</code> 可能偶尔用的到。</li>
</ul>
<h2 id="5-get-和-post的区别"><a href="#5-get-和-post的区别" class="headerlink" title="5 get 和 post的区别"></a>5 get 和 post的区别</h2><p><img src="http://img.smyhvae.com/20180306_1415.png" alt></p>
<ul>
<li>区别有很多，如果记不住，面试时，至少要任意答出其中的三四条。</li>
<li>有一点要强调，<strong>get是相对不隐私的，而post是相对隐私的</strong>。</li>
</ul>
<blockquote>
<p>我们大概要记住以下几点：</p>
</blockquote>
<ol>
<li>浏览器在回退时，<code>get</code> <strong>不会重新请求</strong>，但是<code>post</code>会重新请求。【重要】</li>
<li><code>get</code>请求会被浏览器<strong>主动缓存</strong>，而<code>post</code>不会。【重要】</li>
<li><code>get</code>请求的参数，会报<strong>保留</strong>在浏览器的<strong>历史记录</strong>里，而<code>post</code>不会。做业务时要注意。为了防止<code>CSRF</code>攻击，很多公司把<code>get</code>统一改成了<code>post</code>。</li>
<li><code>get</code>请求在<code>url</code>中<code>传递的参数有大小限制，基本是</code>2kb`，不同的浏览器略有不同。而post没有注意。</li>
<li><code>get</code>的参数是直接暴露在<code>url</code>上的，相对不安全。而<code>post</code>是放在请求体中的。</li>
</ol>
<h2 id="6-http状态码"><a href="#6-http状态码" class="headerlink" title="6 http状态码"></a>6 http状态码</h2><blockquote>
<p><code>http</code>状态码分类：</p>
</blockquote>
<p><img src="http://img.smyhvae.com/20180306_1430.png" alt></p>
<blockquote>
<p>常见的<code>http</code>状态码：</p>
</blockquote>
<p><img src="http://img.smyhvae.com/20180306_1431.png" alt></p>
<p><strong>部分解释</strong>：</p>
<ul>
<li><code>206</code>的应用：<code>range</code>指的是请求的范围，客户端只请求某个大文件里的一部分内容。比如说，如果播放视频地址或音频地址的前面一部分，可以用到<code>206</code>。</li>
<li><code>301</code>：重定向（永久）。</li>
<li><code>302</code>：重定向（临时）。</li>
<li><code>304</code>：我这个服务器告诉客户端，你已经有缓存了，不需要从我这里取了。</li>
</ul>
<p><img src="http://img.smyhvae.com/20180306_1440.png" alt></p>
<ul>
<li><code>400</code>和<code>401</code>用的不多,未授权。<code>403</code>指的是请求被拒绝。<code>404</code>指的是资源不存在。</li>
</ul>
<h2 id="7-持久链接-http长连接"><a href="#7-持久链接-http长连接" class="headerlink" title="7 持久链接/http长连接"></a>7 持久链接/http长连接</h2><blockquote>
<p>如果你能答出持久链接，这是面试官很想知道的一个点。</p>
</blockquote>
<ul>
<li><strong>轮询</strong>：<code>http1.0</code>中，客户端每隔很短的时间，都会对服务器发出请求，查看是否有新的消息，只要轮询速度足够快，例如<code>1</code>秒，就能给人造成交互是实时进行的印象。这种做法是无奈之举，实际上对服务器、客户端双方都造成了大量的性能浪费。</li>
<li><strong>长连接</strong>：<code>HTTP1.1</code>中，通过使用<code>Connection:keep-alive</code>进行长连接，。客户端只请求一次，但是服务器会将继续保持连接，当再次请求时，避免了重新建立连接。</li>
</ul>
<blockquote>
<p>注意，<code>HTTP 1.1</code>默认进行持久连接。在一次 <code>TCP</code> 连接中可以完成多个 <code>HTTP</code> 请求，但是对<strong>每个请求仍然要单独发 header</strong>，<code>Keep-Alive</code>不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如<code>Apache</code>）中设定这个时间。</p>
</blockquote>
<h2 id="8-长连接中的管线化"><a href="#8-长连接中的管线化" class="headerlink" title="8 长连接中的管线化"></a>8 长连接中的管线化</h2><blockquote>
<p>如果能答出<strong>管线化</strong>，则属于加分项。</p>
</blockquote>
<h3 id="8-1-管线化的原理"><a href="#8-1-管线化的原理" class="headerlink" title="8.1 管线化的原理"></a>8.1 管线化的原理</h3><blockquote>
<p>长连接时，<strong>默认</strong>的请求这样的：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">请求1 --&gt; 响应1 --&gt;请求2 --&gt; 响应2 --&gt; 请求3 --&gt; 响应3</span><br></pre></td></tr></table></figure>

<blockquote>
<p>管线化就是，我把现在的请求打包，一次性发过去，你也给我一次响应回来。</p>
</blockquote>
<h3 id="8-2-管线化的注意事项"><a href="#8-2-管线化的注意事项" class="headerlink" title="8.2 管线化的注意事项"></a>8.2 管线化的注意事项</h3><blockquote>
<p>面试时，不会深究管线化。如果真要问你，就回答：“我没怎么研究过，准备回去看看~”</p>
</blockquote>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  
  
  

</article>
    
    <article id="post-HTTP" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    

    
    <div class="article-meta">
      <a href="/2020/04/16/HTTP/" class="article-date">
  <time datetime="2020-04-15T17:37:00.008Z" itemprop="datePublished">2020-04-16</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <p><strong>http状态码有那些？分别代表是什么意思？</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">简单版</span><br><span class="line">   [</span><br><span class="line">       100  Continue   继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息</span><br><span class="line">       200  OK         正常返回信息</span><br><span class="line">       201  Created    请求成功并且服务器创建了新的资源</span><br><span class="line">       202  Accepted   服务器已接受请求，但尚未处理</span><br><span class="line">       301  Moved Permanently  请求的网页已永久移动到新位置。</span><br><span class="line">       302 Found       临时性重定向。</span><br><span class="line">       303 See Other   临时性重定向，且总是使用 GET 请求新的 URI。</span><br><span class="line">       304  Not Modified 自从上次请求后，请求的网页未修改过。</span><br><span class="line"></span><br><span class="line">       400 Bad Request  服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。</span><br><span class="line">       401 Unauthorized 请求未授权。</span><br><span class="line">       403 Forbidden   禁止访问。</span><br><span class="line">       404 Not Found   找不到如何与 URI 相匹配的资源。</span><br><span class="line"></span><br><span class="line">       500 Internal Server Error  最常见的服务器端错误。</span><br><span class="line">       503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。</span><br><span class="line">   ]</span><br></pre></td></tr></table></figure>

<p><strong>一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）</strong></p>
<ul>
<li><p>注：这题胜在区分度高，知识点覆盖广，再不懂的人，也能答出几句，</p>
</li>
<li><p>而高手可以根据自己擅长的领域自由发挥，从URL规范、HTTP协议、DNS、CDN、数据库查询、</p>
</li>
<li><p>到浏览器流式解析、CSS规则构建、layout、paint、onload/domready、JS执行、JS API绑定等等；</p>
</li>
<li><p>详细版：</p>
<ul>
<li>浏览器会开启一个线程来处理这个请求，对 URL 分析判断如果是 http 协议就按照 Web 方式来处理;</li>
<li>调用浏览器内核中的对应方法，比如 WebView 中的 loadUrl 方法;</li>
<li>通过DNS解析获取网址的IP地址，设置 UA 等信息发出第二个GET请求;</li>
<li>进行HTTP协议会话，客户端发送报头(请求报头);</li>
<li>进入到web服务器上的 Web Server，如 Apache、Tomcat、Node.JS 等服务器;</li>
<li>进入部署好的后端应用，如 PHP、Java、JavaScript、Python 等，找到对应的请求处理;</li>
<li>处理结束回馈报头，此处如果浏览器访问过，缓存上有对应资源，会与服务器最后修改时间对比，一致则返回304;</li>
<li>浏览器开始下载html文档(响应报头，状态码200)，同时使用缓存;</li>
<li>文档树建立，根据标记请求所需指定MIME类型的文件（比如css、js）,同时设置了cookie;</li>
<li>页面开始渲染DOM，JS根据DOM API操作DOM,执行事件绑定等，页面显示完成。</li>
</ul>
</li>
<li><p>简洁版：</p>
<ul>
<li>浏览器根据请求的URL交给DNS域名解析，找到真实IP，向服务器发起请求；</li>
<li>服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS、图象等）；</li>
<li>浏览器对加载到的资源（HTML、JS、CSS等）进行语法解析，建立相应的内部数据结构（如HTML的DOM）；</li>
<li>载入解析到的资源文件，渲染页面，完成。</li>
</ul>
</li>
</ul>
<p><strong>说说TCP传输的三次握手四次挥手策略</strong></p>
<ul>
<li><p>为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。用TCP协议把数据包送出去后，TCP不会对传送 后的情况置之不理，它一定会向对方确认是否成功送达。握手过程中使用了TCP的标志：SYN和ACK</p>
</li>
<li><p>发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息。 最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。 若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包</p>
</li>
</ul>
<p><strong>断开一个TCP连接则需要“四次握手”：</strong></p>
<ul>
<li><p>第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据</p>
</li>
<li><p>第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）</p>
</li>
<li><p>第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了</p>
</li>
<li><p>第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手</p>
</li>
</ul>
<p><strong>TCP和UDP的区别</strong></p>
<ul>
<li><p>TCP（Transmission Control Protocol，传输控制协议）是基于连接的协议，也就是说，在正式收发数据前，必须和对方建立可靠的连接。一个TCP连接必须要经过三次“对话”才能建立起来</p>
</li>
<li><p>UDP（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去！ UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境</p>
</li>
</ul>
<p><strong>HTTP和HTTPS</strong></p>
<ul>
<li>HTTP协议通常承载于TCP协议之上，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的HTTPS</li>
<li>默认HTTP的端口号为80，HTTPS的端口号为443</li>
</ul>
<p><strong>为什么HTTPS安全</strong></p>
<ul>
<li>因为网络请求需要中间有很多的服务器路由器的转发。中间的节点都可能篡改信息，而如果使用HTTPS，密钥在你和终点站才有。https之所以比http安全，是因为他利用ssl/tls协议传输。它包含证书，卸载，流量转发，负载均衡，页面适配，浏览器适配，refer传递等。保障了传输过程的安全性</li>
</ul>
<p><strong>关于Http 2.0 你知道多少？</strong></p>
<ul>
<li><p>HTTP/2引入了“服务端推（server push）”的概念，它允许服务端在客户端需要数据之前就主动地将数据发送到客户端缓存中，从而提高性能。</p>
</li>
<li><p>HTTP/2提供更多的加密支持</p>
</li>
<li><p>HTTP/2使用多路技术，允许多个消息在一个连接上同时交差。</p>
</li>
<li><p>它增加了头压缩（header compression），因此即使非常小的请求，其请求和响应的header都只会占用很小比例的带宽</p>
</li>
</ul>
<p><strong>GET和POST的区别，何时使用POST？</strong></p>
<ul>
<li><p>GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符</p>
</li>
<li><p>POST：一般用于修改服务器上的资源，对所发送的信息没有限制。</p>
</li>
<li><p>GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值，也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。</p>
</li>
<li><p>然而，在以下情况中，请使用 POST 请求：</p>
<ul>
<li><p>无法使用缓存文件（更新服务器上的文件或数据库）</p>
</li>
<li><p>向服务器发送大量数据（POST 没有数据量限制）</p>
</li>
<li><p>发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠</p>
</li>
</ul>
</li>
</ul>
<p><strong>说说网络分层里七层模型是哪七层</strong></p>
<ul>
<li><p>应用层：应用层、表示层、会话层（从上往下）（HTTP、FTP、SMTP、DNS）</p>
</li>
<li><p>传输层（TCP和UDP）</p>
</li>
<li><p>网络层（IP）</p>
</li>
<li><p>物理和数据链路层（以太网）</p>
</li>
</ul>
<ul>
<li><p>每一层的作用如下：</p>
<ul>
<li>物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）<br>数据链路层：将比特组装成帧和点到点的传递（帧Frame）</li>
<li>网络层：负责数据包从源到宿的传递和网际互连（包PackeT）</li>
<li>传输层：提供端到端的可靠报文传递和错误恢复（段Segment）</li>
<li>会话层：建立、管理和终止会话（会话协议数据单元SPDU）</li>
<li>表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）</li>
<li>应用层：允许访问OSI环境的手段（应用协议数据单元APDU）</li>
</ul>
</li>
</ul>
<p><strong>讲讲304缓存的原理</strong></p>
<ul>
<li>服务器首先产生ETag，服务器可在稍后使用它来判断页面是否已经被修改。本质上，客户端通过将该记号传回服务器要求服务器验证其（客户端）缓存</li>
<li>304是HTTP状态码，服务器用来标识这个文件没修改，不返回内容，浏览器在接收到个状态码后，会使用浏览器已缓存的文件</li>
<li>客户端请求一个页面（A）。 服务器返回页面A，并在给A加上一个ETag。 客户端展现该页面，并将页面连同ETag一起缓存。 客户再次请求页面A，并将上次请求时服务器返回的ETag一起传递给服务器。 服务器检查该ETag，并判断出该页面自上次客户端请求之后还未被修改，直接返回响应304（未修改——Not Modified）和一个空的响应体</li>
</ul>
<p><strong>HTTP/2 与 HTTP/1.x 的关键区别</strong></p>
<ul>
<li>二进制协议代替文本协议，更加简洁高效</li>
<li>针对每个域只使用一个多路复用的连接</li>
<li>压缩头部信息减小开销</li>
<li>允许服务器主动推送应答到客户端的缓存中</li>
</ul>
<p><strong>一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？</strong></p>
<ul>
<li>01.浏览器查找域名对应的IP地址(DNS 查询：浏览器缓存-&gt;系统缓存-&gt;路由器缓存-&gt;ISP DNS 缓存-&gt;根域名服务器)</li>
<li>02.浏览器向 Web 服务器发送一个 HTTP 请求（TCP三次握手）</li>
<li>03.服务器 301 重定向（从 <a href="http://example.com" target="_blank" rel="noopener">http://example.com</a> 重定向到 <a href="http://www.example.com）" target="_blank" rel="noopener">http://www.example.com）</a></li>
<li>04.浏览器跟踪重定向地址，请求另一个带 www 的网址</li>
<li>05.服务器处理请求（通过路由读取资源）</li>
<li>06.服务器返回一个 HTTP 响应（报头中把 Content-type 设置为 ‘text/html’）</li>
<li>07.浏览器进 DOM 树构建</li>
<li>08.浏览器发送请求获取嵌在 HTML 中的资源（如图片、音频、视频、CSS、JS等）</li>
<li>09.浏览器显示完成页面</li>
<li>10.浏览器发送异步请求</li>
</ul>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  
  
  

</article>
    
    <article id="post-HTML" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    

    
    <div class="article-meta">
      <a href="/2020/04/16/HTML/" class="article-date">
  <time datetime="2020-04-15T17:36:59.996Z" itemprop="datePublished">2020-04-16</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><hr>
<p><strong>语义化</strong></p>
<ul>
<li><p>HTML标签的语义化是指：通过使用包含语义的标签（如h1-h6）恰当地表示文档结构</p>
</li>
<li><p>css命名的语义化是指：为html标签添加有意义的class</p>
</li>
<li><p>为什么需要语义化：</p>
<ul>
<li>去掉样式后页面呈现清晰的结构</li>
<li>盲人使用读屏器更好地阅读</li>
<li>搜索引擎更好地理解页面，有利于收录</li>
<li>便团队项目的可持续运作及维护</li>
</ul>
</li>
</ul>
<p><strong>简述一下你对HTML语义化的理解？</strong></p>
<ul>
<li>用正确的标签做正确的事情。</li>
<li>html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;</li>
<li>即使在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的;</li>
<li>搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO;</li>
<li>使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解</li>
</ul>
<p><strong>Doctype作用？标准模式与兼容模式各有什么区别?</strong></p>
<ul>
<li><code>&lt;!DOCTYPE&gt;</code>声明位于位<code>于HTML</code>文档中的第一行，处于 <code>&lt;html&gt;</code> 标签之前。告知浏览器的解析器用什么文档标准解析这个文档。<code>DOCTYPE</code>不存在或格式不正确会导致文档以兼容模式呈现</li>
<li>标准模式的排版 和JS运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作</li>
</ul>
<p><strong>HTML5 为什么只需要写 <!DOCTYPE HTML>？</strong></p>
<ul>
<li>HTML5 不基于 SGML，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为（让浏览器按照它们应该的方式来运行）</li>
<li>而HTML4.01基于SGML,所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型</li>
</ul>
<p><strong>行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？</strong></p>
<ul>
<li>行内元素有：<code>a b span img input select strong</code>（强调的语气）</li>
<li>块级元素有：<code>div ul ol li dl dt dd h1 h2 h3 h4…p</code></li>
<li>常见的空元素:<code>&lt;br&gt; &lt;hr&gt; &lt;img&gt; &lt;input&gt; &lt;link&gt; &lt;meta&gt;</code></li>
</ul>
<p><strong>页面导入样式时，使用link和@import有什么区别？</strong></p>
<ul>
<li><code>link</code>属于<code>XHTML</code>标签，除了加载<code>CSS</code>外，还能用于定义<code>RSS</code>,定义<code>rel</code>连接属性等作用；而<code>@import</code>是<code>CSS</code>提供的，只能用于加载<code>CSS</code></li>
<li>页面被加载的时，<code>link</code>会同时被加载，而<code>@import</code>引用的<code>CSS</code>会等到页面被加载完再加载</li>
<li><code>import</code>是<code>CSS2.1</code> 提出的，只在<code>IE5</code>以上才能被识别，而<code>link</code>是<code>XHTML</code>标签，无兼容问题</li>
</ul>
<p><strong>介绍一下你对浏览器内核的理解？</strong></p>
<ul>
<li><p>主要分成两部分：渲染引擎(<code>layout engineer</code>或<code>Rendering Engine</code>)和<code>JS</code>引擎</p>
</li>
<li><p>渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核</p>
</li>
<li><p>JS引擎则：解析和执行javascript来实现网页的动态效果</p>
</li>
<li><p>最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎</p>
</li>
</ul>
<p><strong>常见的浏览器内核有哪些？</strong></p>
<ul>
<li><code>Trident</code>内核：<code>IE,MaxThon,TT,The World,360</code>,搜狗浏览器等。[又称MSHTML]</li>
<li><code>Gecko</code>内核：<code>Netscape6</code>及以上版本，<code>FF,MozillaSuite/SeaMonkey</code>等</li>
<li><code>Presto</code>内核：<code>Opera7</code>及以上。      [<code>Opera</code>内核原为：Presto，现为：<code>Blink</code>;]</li>
<li><code>Webkit</code>内核：<code>Safari,Chrome</code>等。   [ <code>Chrome</code>的<code>Blink</code>（<code>WebKit</code>的分支）]</li>
</ul>
<p><strong>html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？</strong></p>
<ul>
<li><p>HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加</p>
<ul>
<li>绘画 canvas</li>
<li>用于媒介回放的 video 和 audio 元素</li>
<li>本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失</li>
<li>sessionStorage 的数据在浏览器关闭后自动删除</li>
<li>语意化更好的内容元素，比如 article、footer、header、nav、section</li>
<li>表单控件，calendar、date、time、email、url、search</li>
<li>新的技术webworker, websocket, Geolocation</li>
</ul>
</li>
<li><p>移除的元素：</p>
<ul>
<li>纯表现的元素：basefont，big，center，font, s，strike，tt，u</li>
<li>对可用性产生负面影响的元素：frame，frameset，noframes</li>
</ul>
</li>
<li><p>支持HTML5新标签：</p>
<ul>
<li>IE8/IE7/IE6支持通过document.createElement方法产生的标签</li>
<li>可以利用这一特性让这些浏览器支持HTML5新标签</li>
<li>浏览器支持新标签后，还需要添加标签默认的样式</li>
</ul>
</li>
<li><p>当然也可以直接使用成熟的框架、比如html5shim</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--[if lt IE 9]&gt;</span><br><span class="line">&lt;script&gt; src=&quot;http://html5shim.googlecode.com</span><br><span class="line">/svn/trunk/html5.js&quot;&lt;/script&gt;&lt;![endif]--&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>如何区分HTML5： DOCTYPE声明\新增的结构元素\功能元素</li>
</ul>
<p><strong>HTML5的离线储存怎么使用，工作原理能不能解释一下？</strong></p>
<ul>
<li><p>在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件</p>
</li>
<li><p>原理：HTML5的离线存储是基于一个新建的.appcache文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示</p>
</li>
<li><p>如何使用：</p>
<ul>
<li>页面头部像下面一样加入一个manifest的属性；</li>
<li>在cache.manifest文件的编写离线存储的资源</li>
<li>在离线状态时，操作window.applicationCache进行需求实现<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CACHE MANIFEST</span><br><span class="line">    #v0.11</span><br><span class="line">    CACHE:</span><br><span class="line">    js/app.js</span><br><span class="line">    css/style.css</span><br><span class="line">    NETWORK:</span><br><span class="line">    resourse/logo.png</span><br><span class="line">    FALLBACK:</span><br><span class="line">    / /offline.html</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<p><strong>浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？</strong></p>
<ul>
<li><p>在线的情况下，浏览器发现html头部有manifest属性，它会请求manifest文件，如果是第一次访问app，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。如果已经访问过app并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。</p>
</li>
<li><p>离线的情况下，浏览器就直接使用离线存储的资源。</p>
</li>
</ul>
<p><strong>请描述一下 cookies，sessionStorage 和 localStorage 的区别？</strong></p>
<ul>
<li><p>cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）</p>
</li>
<li><p>cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递</p>
</li>
<li><p><code>sessionStorage</code>和<code>localStorage</code>不会自动把数据发给服务器，仅在本地保存</p>
</li>
<li><p>存储大小：</p>
<ul>
<li><code>cookie</code>数据大小不能超过4k</li>
<li><code>sessionStorage</code>和<code>localStorage</code>虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大</li>
</ul>
</li>
<li><p>有期时间：</p>
<ul>
<li><code>localStorage</code> 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据</li>
<li><code>sessionStorage</code>  数据在当前浏览器窗口关闭后自动删除</li>
<li><code>cookie</code>  设置的<code>cookie</code>过期时间之前一直有效，即使窗口或浏览器关闭</li>
</ul>
</li>
</ul>
<p><strong>iframe有那些缺点？</strong></p>
<ul>
<li>iframe会阻塞主页面的Onload事件</li>
<li>搜索引擎的检索程序无法解读这种页面，不利于SEO</li>
<li>iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载</li>
<li>使用<code>iframe</code>之前需要考虑这两个缺点。如果需要使用<code>iframe</code>，最好是通过<code>javascript</code>动态给<code>iframe</code>添加<code>src</code>属性值，这样可以绕开以上两个问题</li>
</ul>
<p><strong>Label的作用是什么？是怎么用的？</strong></p>
<ul>
<li>label标签来定义表单控制间的关系,当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件</li>
</ul>
<p><strong>HTML5的form如何关闭自动完成功能？</strong></p>
<ul>
<li>给不想要提示的 form 或某个 input 设置为 autocomplete=off。</li>
</ul>
<p><strong>如何实现浏览器内多个标签页之间的通信? (阿里)</strong></p>
<ul>
<li>WebSocket、SharedWorker</li>
<li>也可以调用localstorge、cookies等本地存储方式</li>
</ul>
<p><strong>webSocket如何兼容低浏览器？(阿里)</strong></p>
<ul>
<li>Adobe Flash Socket 、</li>
<li>ActiveX HTMLFile (IE) 、</li>
<li>基于 multipart 编码发送 XHR 、</li>
<li>基于长轮询的 XHR</li>
</ul>
<p><strong>页面可见性（Page Visibility API） 可以有哪些用途？</strong></p>
<ul>
<li>通过 visibilityState 的值检测页面当前是否可见，以及打开网页的时间等;</li>
<li>在页面被切换到其他后台进程的时候，自动暂停音乐或视频的播放</li>
</ul>
<p><strong>如何在页面上实现一个圆形的可点击区域？</strong></p>
<ul>
<li>map+area或者svg</li>
<li>border-radius</li>
<li>纯js实现 需要求一个点在不在圆上简单算法、获取鼠标坐标等等</li>
</ul>
<p><strong>实现不使用 border 画出1px高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&quot;height:1px;overflow:hidden;background:red&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p><strong>网页验证码是干嘛的，是为了解决什么安全问题</strong></p>
<ul>
<li>区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水</li>
<li>有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试</li>
</ul>
<p><strong>title与h1的区别、b与strong的区别、i与em的区别？</strong></p>
<ul>
<li><code>title</code>属性没有明确意义只表示是个标题，H1则表示层次明确的标题，对页面信息的抓取也有很大的影响</li>
<li><code>strong</code>是标明重点内容，有语气加强的含义，使用阅读设备阅读网络时：<strong>会重读，而<b>是展示强调内容</b></strong></li>
<li>i内容展示为斜体，em表示强调的文本</li>
</ul>
<p><strong>页面导入样式时，使用 link 和 @import 有什么区别？</strong></p>
<ul>
<li>link 属于HTML标签，除了加载CSS外，还能用于定 RSS等；@import 只能用于加载CSS</li>
<li>页面加载的时，link 会同时被加载，而 @import 引用的 CSS 会等到页面被加载完再加载</li>
<li>@import 只在 IE5 以上才能被识别，而 link 是HTML标签，无兼容问题</li>
</ul>
<p><strong>介绍一下你对浏览器内核的理解？</strong></p>
<ul>
<li>浏览器内核主要分为两部分：渲染引擎(layout engineer 或 Rendering Engine) 和 JS引擎</li>
<li>渲染引擎负责取得网页的内容进行布局计和样式渲染，然后会输出至显示器或打印机</li>
<li>JS引擎则负责解析和执行JS脚本来实现网页的动态效果和用户交互</li>
<li>最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎</li>
</ul>
<p><strong>常见的浏览器内核有哪些？</strong></p>
<ul>
<li>Blink内核：新版 Chrome、新版 Opera</li>
<li>Webkit内核：Safari、原Chrome</li>
<li>Gecko内核：FireFox、Netscape6及以上版本</li>
<li>Trident内核（又称MSHTML内核）：IE、国产浏览器</li>
<li>Presto内核：原Opera7及以上</li>
</ul>
<p><strong>HTML5有哪些新特性？</strong></p>
<ul>
<li>新增选择器 document.querySelector、document.querySelectorAll</li>
<li>拖拽释放(Drag and drop) API</li>
<li>媒体播放的 video 和 audio</li>
<li>本地存储 localStorage 和 sessionStorage</li>
<li>离线应用 manifest</li>
<li>桌面通知 Notifications</li>
<li>语意化标签 article、footer、header、nav、section</li>
<li>增强表单控件 calendar、date、time、email、url、search</li>
<li>地理位置 Geolocation</li>
<li>多任务 webworker</li>
<li>全双工通信协议 websocket</li>
<li>历史管理 history</li>
<li>跨域资源共享(CORS) Access-Control-Allow-Origin</li>
<li>页面可见性改变事件 visibilitychange</li>
<li>跨窗口通信 PostMessage</li>
<li>Form Data 对象</li>
<li>绘画 canvas</li>
</ul>
<p><strong>HTML5移除了那些元素？</strong></p>
<ul>
<li>纯表现的元素：basefont、big、center、font、s、strike、tt、u</li>
<li>对可用性产生负面影响的元素：frame、frameset、noframes</li>
</ul>
<p><strong>如何处理HTML5新标签的浏览器兼容问题？</strong></p>
<ul>
<li>通过 document.createElement 创建新标签</li>
<li>使用垫片 html5shiv.js</li>
</ul>
<p><strong>如何区分 HTML 和 HTML5？</strong></p>
<ul>
<li>DOCTYPE声明、新增的结构元素、功能元素</li>
</ul>
<p><strong>HTML5的离线储存工作原理能不能解释一下，怎么使用？</strong></p>
<ul>
<li><p>HTML5的离线储存原理：</p>
<ul>
<li>用户在线时，保存更新用户机器上的缓存文件；当用户离线时，可以正常访离线储存问站点或应用内容</li>
</ul>
</li>
<li><p>HTML5的离线储存使用：</p>
<ul>
<li>在文档的 html 标签设置 manifest 属性，如 manifest=”/offline.appcache”</li>
<li>在项目中新建 manifest 文件，manifest 文件的命名建议：xxx.appcache</li>
<li>在 web 服务器配置正确的 MIME-type，即 text/cache-manifest</li>
</ul>
</li>
</ul>
<p><strong>浏览器是怎么对HTML5的离线储存资源进行管理和加载的？</strong></p>
<ul>
<li>在线的情况下，浏览器发现 html 标签有 manifest 属性，它会请求 manifest 文件</li>
<li>如果是第一次访问app，那么浏览器就会根据 manifest 文件的内容下载相应的资源并且进行离线存储</li>
<li>如果已经访问过app且资源已经离线存储了，浏览器会对比新的 manifest 文件与旧的 manifest 文件，如果文件没有发生改变，就不做任何操作。如果文件改变了，那么就会重新下载文件中的资源并进行离线存储</li>
<li>离线的情况下，浏览器就直接使用离线存储的资源。</li>
</ul>
<p><strong>iframe 有那些优点和缺点？</strong></p>
<ul>
<li><p>优点：</p>
<ul>
<li>用来加载速度较慢的内容（如广告）</li>
<li>可以使脚本可以并行下载</li>
<li>可以实现跨子域通信</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>iframe 会阻塞主页面的 onload 事件</li>
<li>无法被一些搜索引擎索识别</li>
<li>会产生很多页面，不容易管理</li>
</ul>
</li>
</ul>
<p><strong>label 的作用是什么？怎么使用的？</strong></p>
<ul>
<li><p>label标签来定义表单控件的关系：</p>
<ul>
<li>当用户选择label标签时，浏览器会自动将焦点转到和label标签相关的表单控件上</li>
</ul>
</li>
<li><p>使用方法1：</p>
<ul>
<li><code>&lt;label for=&quot;mobile&quot;&gt;Number:&lt;/label&gt;</code></li>
<li><code>&lt;input type=&quot;text&quot; id=&quot;mobile&quot;/&gt;</code></li>
</ul>
</li>
<li><p>使用方法2：</p>
<ul>
<li><code>&lt;label&gt;Date:&lt;input type=&quot;text&quot;/&gt;&lt;/label&gt;</code></li>
</ul>
</li>
</ul>
<p><strong>如何实现浏览器内多个标签页之间的通信？</strong></p>
<ul>
<li>iframe + contentWindow</li>
<li>postMessage</li>
<li>SharedWorker(Web Worker API)</li>
<li>storage 事件(localStorge API)</li>
<li>WebSocket</li>
</ul>
<p><strong>webSocket 如何兼容低浏览器？</strong></p>
<ul>
<li>Adobe Flash Socket</li>
<li>ActiveX HTMLFile (IE)</li>
<li>基于 multipart 编码发送 XHR</li>
<li>基于长轮询的 XHR</li>
</ul>
<p><strong>页面可见性（Page Visibility API） 可以有哪些用途？</strong></p>
<ul>
<li>在页面被切换到其他后台进程的时候，自动暂停音乐或视频的播放</li>
<li>当用户浏览其他页面，暂停网站首页幻灯自动播放</li>
<li>完成登陆后，无刷新自动同步其他页面的登录状态</li>
</ul>
<p><strong>title 与 h1 的区别、b 与 strong 的区别、i 与 em 的区别？</strong></p>
<ul>
<li>title 表示是整个页面标题，h1 则表示层次明确的标题，对页面信息的抓取有很大的影响</li>
<li>strong 标明重点内容，有语气加强的含义，使用阅读设备阅读网络时，strong 会重读，而 b </li>
</ul>
<p><strong>是展示强调内容</strong></p>
<ul>
<li>i 内容展示为斜体，em 表示强调的文本</li>
<li>自然样式标签：b, i, u, s, pre</li>
<li>语义样式标签：strong, em, ins, del, code</li>
<li>应该准确使用语义样式标签, 但不能滥用。如果不能确定时，首选使用自然样式标签</li>
</ul>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  
  
  

</article>
    
    <article id="post-Handwritten-code" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    

    
    <div class="article-meta">
      <a href="/2020/04/16/Handwritten-code/" class="article-date">
  <time datetime="2020-04-15T17:36:59.992Z" itemprop="datePublished">2020-04-16</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <p><strong>手写事件侦听器，并要求兼容浏览器</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> eventUtil = &#123;</span><br><span class="line">  getEvent: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> event || <span class="built_in">window</span>.event;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  getTarget: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> event.target || event.srcElement;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  addListener: <span class="function"><span class="keyword">function</span>(<span class="params">element, type, hander</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (element.addEventListener) &#123;</span><br><span class="line">          element.addEventListener(type, hander, <span class="literal">false</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.attachEvent) &#123;</span><br><span class="line">          element.attachEvent(<span class="string">'on'</span> + type, hander);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          element[<span class="string">'on'</span> + type] = hander;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  removeListener: <span class="function"><span class="keyword">function</span>(<span class="params">element, type, hander</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (element.removeEventListener) &#123;</span><br><span class="line">          element.removeEventListener(type, hander, <span class="literal">false</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.deattachEvent) &#123;</span><br><span class="line">          element.detachEvent(type, hander);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          element[<span class="string">'on'</span> + type] = <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  preventDefault: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (event.preventDefault) &#123;</span><br><span class="line">          event.preventDefault();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          event.returnValue = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  stopPropagation: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (event.stopPropagation) &#123;</span><br><span class="line">          event.stopPropagation();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          event.cancelBubble = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"btn"</span>);</span><br><span class="line">  <span class="keyword">var</span> link = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"a"</span>)[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">  eventUtil.addListener(btn, <span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> event = eventUtil.getEvent(event);</span><br><span class="line">      <span class="keyword">var</span> target = eventUtil.getTarget(event);</span><br><span class="line">      alert(event.type);</span><br><span class="line">      alert(target);</span><br><span class="line">      eventUtil.stopPropagation(event);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  eventUtil.addListener(link, <span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">      alert(<span class="string">"prevent default event"</span>);</span><br><span class="line">      <span class="keyword">var</span> event = eventUtil.getEvent(event);</span><br><span class="line">      eventUtil.preventDefault(event);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  eventUtil.addListener(<span class="built_in">document</span>.body, <span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      alert(<span class="string">"click body"</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p><strong>手写事件模型</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Event = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> list = &#123;&#125;, bind, trigger, remove;</span><br><span class="line">    bind = <span class="function"><span class="keyword">function</span> (<span class="params">key, fn</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!list[key]) &#123;</span><br><span class="line">            list[key] = [];</span><br><span class="line">        &#125;</span><br><span class="line">        list[key].push(fn);</span><br><span class="line">    &#125;;</span><br><span class="line">    trigger = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> key = <span class="built_in">Array</span>.prototype.shift.call(<span class="built_in">arguments</span>);</span><br><span class="line">        <span class="keyword">var</span> fns = list[key];</span><br><span class="line">        <span class="keyword">if</span> (!fns || fns.length === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, fn; fn = fns[i++];) &#123;</span><br><span class="line">            fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    remove = <span class="function"><span class="keyword">function</span> (<span class="params">key, fn</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> fns = list[key];</span><br><span class="line">        <span class="keyword">if</span> (!fns) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!fn) &#123;</span><br><span class="line">            fns &amp; (fns.length = <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = fns.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="keyword">var</span> _fn = fns[i];</span><br><span class="line">                <span class="keyword">if</span> (_fn === fn) &#123;</span><br><span class="line">                    fns.splice(i, <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        bind: bind,</span><br><span class="line">        trigger: trigger,</span><br><span class="line">        remove: remove</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">Event.bind(<span class="string">'Hit'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log(<span class="string">'bind event'</span>); &#125;); <span class="comment">// 绑定事件</span></span><br><span class="line">Event.trigger(<span class="string">"Hit"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log(<span class="string">'trigger event'</span>); &#125;); <span class="comment">// 触发事件</span></span><br></pre></td></tr></table></figure>

<p><strong>手写事件代理，并要求兼容浏览器</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delegateEvent</span>(<span class="params">parentEl, selector, type, fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> handler = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">          <span class="keyword">var</span> e = e || <span class="built_in">window</span>.event;</span><br><span class="line">          <span class="keyword">var</span> target = e.target || e.srcElement;</span><br><span class="line">          <span class="keyword">if</span> (matchSelector(target, selector)) &#123;</span><br><span class="line">              <span class="keyword">if</span>(fn) &#123;</span><br><span class="line">                  fn.call(target, e);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span>(parentEl.addEventListener)&#123;</span><br><span class="line">        parentEl.addEventListener(type, handler);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        parentEl.attachEvent(<span class="string">"on"</span> + type, handler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * support #id, tagName, .className</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">matchSelector</span>(<span class="params">ele, selector</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// if use id</span></span><br><span class="line">    <span class="keyword">if</span> (selector.charAt(<span class="number">0</span>) === <span class="string">"#"</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ele.id === selector.slice(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// if use class</span></span><br><span class="line">    <span class="keyword">if</span> (selector.charAt(<span class="number">0</span>) === <span class="string">"."</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">" "</span> + ele.className + <span class="string">" "</span>).indexOf(<span class="string">" "</span> + selector.slice(<span class="number">1</span>) + <span class="string">" "</span>) != <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// if use tagName</span></span><br><span class="line">    <span class="keyword">return</span> ele.tagName.toLowerCase() === selector.toLowerCase();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="keyword">var</span> box = <span class="built_in">document</span>.getElementById(<span class="string">"box"</span>);</span><br><span class="line">delegateEvent(box, <span class="string">"a"</span>, <span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.href);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>手写事件触发器，并要求兼容浏览器</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fireEvent = <span class="function"><span class="keyword">function</span>(<span class="params">element, event</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">document</span>.createEventObject)&#123;</span><br><span class="line">        <span class="keyword">var</span> mockEvent = <span class="built_in">document</span>.createEventObject();</span><br><span class="line">        <span class="keyword">return</span> element.fireEvent(<span class="string">'on'</span> + event, mockEvent)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> mockEvent = <span class="built_in">document</span>.createEvent(<span class="string">'HTMLEvents'</span>);</span><br><span class="line">        mockEvent.initEvent(event, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> element.dispatchEvent(mockEvent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>手写 Function.bind 函数</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Function</span>.prototype.bind) &#123;</span><br><span class="line">  <span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span> (<span class="params">oThis</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">"function"</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"'this' is not function"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bind's default arguments, array without first element</span></span><br><span class="line">    <span class="comment">// first part arguments for the function</span></span><br><span class="line">    <span class="keyword">var</span> aBindArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">var</span> fToBind = <span class="keyword">this</span>; <span class="comment">// the function will be binding</span></span><br><span class="line">    <span class="keyword">var</span> fNOP = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">    <span class="keyword">var</span> fBound = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="comment">// target this will be binding</span></span><br><span class="line">          <span class="keyword">var</span> oThis = <span class="keyword">this</span> <span class="keyword">instanceof</span> fNOP ? <span class="keyword">this</span> : oThis || <span class="keyword">this</span>;</span><br><span class="line">          <span class="comment">// last part arguments for the function</span></span><br><span class="line">          <span class="keyword">var</span> aCallArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">          <span class="comment">// complete arguments for the function</span></span><br><span class="line">          <span class="keyword">var</span> aFuncArgs = aBindArgs.concat(aCallArgs);</span><br><span class="line">          <span class="keyword">return</span> fToBind.apply(oThis, aFuncArgs);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fBound extends fToBind</span></span><br><span class="line">    fNOP.prototype = <span class="keyword">this</span>.prototype;</span><br><span class="line">    fBound.prototype = <span class="keyword">new</span> fNOP();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fBound;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">a, b, c</span>)</span>&#123; <span class="keyword">return</span> a + b + c;&#125;;</span><br><span class="line"><span class="keyword">var</span> newAdd = add.bind(<span class="literal">null</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">var</span> result = newAdd(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p><strong>手写数组快速排序</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> quickSort = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt;= <span class="number">1</span>) &#123; <span class="keyword">return</span> arr; &#125;</span><br><span class="line">    <span class="keyword">var</span> pivotIndex = <span class="built_in">Math</span>.floor(arr.length / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">var</span> pivot = arr.splice(pivotIndex, <span class="number">1</span>)[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">var</span> left = [];</span><br><span class="line">    <span class="keyword">var</span> right = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; pivot) &#123;</span><br><span class="line">          left.push(arr[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          right.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> quickSort(left).concat([pivot], quickSort(right));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">quickSort([<span class="number">9</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">7</span>]);</span><br></pre></td></tr></table></figure>

<p><strong>手写数组冒泡排序</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bubble = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> maxIndex = arr.length - <span class="number">1</span>, temp, flag;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = maxIndex; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        flag = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(! flag)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="keyword">var</span> arr = bubble([<span class="number">13</span>, <span class="number">69</span>, <span class="number">28</span>, <span class="number">93</span>, <span class="number">55</span>, <span class="number">75</span>, <span class="number">34</span>]);</span><br></pre></td></tr></table></figure>

<p><strong>手写数组去重</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.unique = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> [...new <span class="built_in">Set</span>(<span class="keyword">this</span>)];&#125;;</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>].unique();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique1</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> hash = &#123;&#125;, result = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>, len=arr.length; i&lt;len; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(! hash[arr[i]])&#123;</span><br><span class="line">          result.push(arr[i]);</span><br><span class="line">          hash[arr[i]] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">unique1([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.unique2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sort();</span><br><span class="line">    <span class="keyword">var</span> result = [<span class="keyword">this</span>[<span class="number">0</span>]];</span><br><span class="line">    <span class="keyword">var</span> len = <span class="keyword">this</span>.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>[i] !== result[result.length - <span class="number">1</span>])&#123;</span><br><span class="line">          result.push(<span class="keyword">this</span>[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>].unique2();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique3</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(result.indexOf(arr[i]) == <span class="number">-1</span>)&#123;</span><br><span class="line">          result.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">unique3([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]);</span><br></pre></td></tr></table></figure>

<p><strong>将url的查询参数解析成字典对象</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseQuery</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  url = url == <span class="literal">null</span> ? <span class="built_in">window</span>.location.href : url;</span><br><span class="line">  <span class="keyword">var</span> search = url.substring(url.lastIndexOf(<span class="string">"?"</span>) + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">var</span> hash = &#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> reg = <span class="regexp">/([^?&amp;=]+)=([^?&amp;=]*)/g</span>;</span><br><span class="line">  search.replace(reg, <span class="function"><span class="keyword">function</span> (<span class="params">match, $<span class="number">1</span>, $<span class="number">2</span></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> name = <span class="built_in">decodeURIComponent</span>($<span class="number">1</span>);</span><br><span class="line">      <span class="keyword">var</span> val = <span class="built_in">decodeURIComponent</span>($<span class="number">2</span>);</span><br><span class="line">      hash[name] = <span class="built_in">String</span>(val);</span><br><span class="line">      <span class="keyword">return</span> match;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>封装函数节流函数</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> throttle = <span class="function"><span class="keyword">function</span>(<span class="params">fn, delay, mustRunDelay</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timer = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">var</span> t_start;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context = <span class="keyword">this</span>, args = <span class="built_in">arguments</span>, t_curr = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    clearTimeout(timer);</span><br><span class="line">    <span class="keyword">if</span>(!t_start)&#123;</span><br><span class="line">      t_start = t_curr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(t_curr - t_start &gt;= mustRunDelay)&#123;</span><br><span class="line">      fn.apply(context, args);</span><br><span class="line">      t_start = t_curr;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        fn.apply(context, args);</span><br><span class="line">      &#125;, delay);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用（两次间隔50ms内连续触发不执行，但每累计100ms至少执行一次</span></span><br><span class="line"><span class="built_in">window</span>.onresize = throttle(myFunc, <span class="number">50</span>, <span class="number">100</span>);</span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure>

<p><strong>用JS实现千位分隔符</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> str = (+ num) + <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">var</span> len = str.length;</span><br><span class="line">  <span class="keyword">if</span>(len &lt;= <span class="number">3</span>) <span class="keyword">return</span> str;</span><br><span class="line">  num = <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">while</span>(len &gt; <span class="number">3</span>)&#123;</span><br><span class="line">      len -= <span class="number">3</span>;</span><br><span class="line">      num = <span class="string">','</span> + str.substr(len, <span class="number">3</span>) + num;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> str.substr(<span class="number">0</span>, len) + num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// ?= 正向匹配:匹配位置</span></span><br><span class="line">  <span class="comment">// ?! 正向不匹配:排除位置</span></span><br><span class="line">  <span class="keyword">var</span> str = (+num).toString();</span><br><span class="line">  <span class="keyword">var</span> reg = <span class="regexp">/(?=(?!\b)(\d&#123;3&#125;)+$)/g</span>;</span><br><span class="line">  <span class="keyword">return</span> str.replace(reg, <span class="string">','</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  
  
  

</article>
    
    <article id="post-Git" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    

    
    <div class="article-meta">
      <a href="/2020/04/16/Git/" class="article-date">
  <time datetime="2020-04-15T17:36:59.987Z" itemprop="datePublished">2020-04-16</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <p><strong>git fetch和git pull的区别</strong></p>
<ul>
<li>git pull：相当于是从远程获取最新版本并merge到本地</li>
<li>git fetch：相当于是从远程获取最新版本到本地，不会自动merge</li>
</ul>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  
  
  

</article>
    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2020
        <i class="ri-heart-fill heart_icon"></i> 王金龙
      </li>
    </ul>
   
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></s>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="王金龙"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/旅行/">旅行</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="http://shenyu-vip.lofter.com">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="https://">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="https://">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/lazyload.min.js"></script>

<script>
  try {
    var typed = new Typed("#subtitle", {
      strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
      startDelay: 0,
      typeSpeed: 200,
      loop: true,
      backSpeed: 100,
      showCursor: true
    });
  } catch (err) {
  }

</script>





<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>
<script src="/dist/main.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>




<script src="/js/busuanzi-2.3.pure.min.js"></script>


<script type="text/javascript" src="https://js.users.51.la/20544303.js"></script>


<!-- 复制 -->

  <link rel="stylesheet" href="/css/clipboard.css">
  <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>




    
  </div>
</body>

</html>